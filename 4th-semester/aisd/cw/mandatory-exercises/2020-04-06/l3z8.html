<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title></title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="/style.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@500&display=swap" rel="stylesheet">
</head>
<body>
<h1 id="lista-3-zadanie-8">Lista 3, Zadanie 8</h1>
<h2 id="problem">Problem</h2>
<p>Potrzebujemy algorytmu do sortowania <span class="math inline">\(n\)</span> liczb całkowitych z przedziału od <span class="math inline">\(1\)</span> do <span class="math inline">\(n^2\)</span> w czasie <span class="math inline">\(O(n)\)</span>.</p>
<h2 id="concept">Concept</h2>
<p>Użyjemy tutaj algorytmu <code>RadixSort</code> do podzielenia liczb na części które sortujemy dalej przy pomocy algorytmu <code>CountingSort</code>.</p>
<p>Przy czym, wybór sposobu podziału jest istotny podczas naszego <em>„dzielenia liczb na części”</em>. Zależy nam na złożoności <span class="math inline">\(O(n)\)</span>, więc najlepiej przejść z bazy dziesiętnej na bazę <span class="math inline">\(n\)</span>.<br />
Wówczas <code>CountingSort</code> zostanie użyty tylko dwa razy, jako że mamy tylko <span class="math inline">\(n^2\)</span> liczb do posortowania o postaci <span class="math inline">\((\overline{ab})_n\)</span>, gdzie <span class="math inline">\(a,b\)</span> to cyfry liczby w bazie <span class="math inline">\(n\)</span>.</p>
<p>Oczywiście tutaj pojawia się problem liczby <span class="math inline">\(n^2\)</span> która wykracza poza ten zakres, ponieważ ma postać <span class="math inline">\((100)_n\)</span>.<br />
Rozwiązaniem może być wprowadzenie specjalnego przypadku dla tej liczby, jako że jest to <span class="math inline">\(\max\)</span>imum rozważanego przedziału. Możemy wtedy instancje takich liczb przesuwać na sam koniec posortowanej listy.<br />
Innym rozwiązaniem tutaj może być przesunięcie wszystkich elementów o <span class="math inline">\(1\)</span> lokalnie, na czas sortowania. Wówczas mielibyśmy liczby z zakresu <span class="math inline">\([0,n^2-1]\)</span> które jak najbardziej da się zapisać w formacie <span class="math inline">\((\overline{ab})_n\)</span>.</p>
<p>W <a href="#rozwi%c4%85zanie">rozwiązaniu</a> rozważymy algorytm przesuwający liczby o <span class="math inline">\(1\)</span> żeby zmieściły się w zakresie <span class="math inline">\([0,n^2-1]\)</span>.</p>
<h2 id="rozwiązanie">Rozwiązanie</h2>
<h3 id="pseudokod">Pseudokod</h3>
<p><code>CustomSort</code>:<br />
<code>input :</code> <span class="math inline">\(A\)</span> - lista <span class="math inline">\(n\)</span> liczb z przedziału <span class="math inline">\([1,n^2]\)</span><br />
<code>output:</code> posortowana lista <span class="math inline">\(A&#39;\)</span> 1. <span class="math inline">\(e = 1\)</span> 2. <code>while</code> <span class="math inline">\(e &lt; n^2\)</span> 1. <span class="math inline">\(count[n]\)</span> 2. <span class="math inline">\(i=0\)</span> 3. <code>while</code> <span class="math inline">\(i&lt;n\)</span> 1. <span class="math inline">\(count\left[~\lfloor \frac{A[i]-1}{e} \rfloor\mod n~\right]\)</span><code>++</code> 2. <span class="math inline">\(i\)</span><code>++</code> 4. <span class="math inline">\(i=1\)</span> 5. <code>while</code> <span class="math inline">\(i&lt;n\)</span> 1. <span class="math inline">\(count[i] = count[i-1]\)</span> 2. <span class="math inline">\(i\)</span><code>++</code> 6. <span class="math inline">\(tmp[n]\)</span> 7. <span class="math inline">\(i=n-1\)</span> 8. <code>while</code> <span class="math inline">\(i\ge0\)</span> 1. <span class="math inline">\(tmp\left[count\left[\lfloor \frac{A[i]-1}{e} \rfloor\mod n\right]-1\right] = A[i]\)</span> 2. <span class="math inline">\(count\left[\lfloor \frac{A[i]-1}{e} \rfloor\mod n\right]\)</span><code>--</code> 3. <span class="math inline">\(i\)</span><code>--</code> 9. <span class="math inline">\(i=0\)</span> 10. <code>while</code> <span class="math inline">\(i&lt;n\)</span> 1. <span class="math inline">\(A[i] = tmp[i]\)</span> 2. <span class="math inline">\(i\)</span><code>++</code> 11. <span class="math inline">\(e = e\cdot n\)</span></p>
<h3 id="opis-pseudokodu">Opis pseudokodu</h3>
<ul>
<li><span class="math inline">\(e\)</span> jest eksponentą liczby <span class="math inline">\(n\)</span></li>
<li>Punkt 2. to pętla która zawsze uruchomi się dwa razy (dla naszego przedziału liczb <span class="math inline">\([1,n^2]\)</span>).</li>
<li>Punkty od 2.1 do 2.8 to implementacja funkcji <code>CountSort</code>, która sortuje poszczególne liczby po ich cyfrach w bazie <span class="math inline">\(n\)</span>.</li>
<li>Uwaga: lokalnie (w liście <span class="math inline">\(count\)</span>) następuje przesunięcie o <span class="math inline">\(1\)</span> z powodów opisanych w <a href="#concept">koncepcie problemu</a>.</li>
</ul>
</body>
</html>
