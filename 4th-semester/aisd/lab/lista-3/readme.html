<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title></title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="/style.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@500&display=swap" rel="stylesheet">
</head>
<body>
<h1 id="lista-3">Lista-3</h1>
<h2 id="zadanie-1">Zadanie 1</h2>
<blockquote>
<p>Uzupełnij <a href="../lista-2/readme.md#zadanie-2">zadanie 2 z listy 2</a> o algorytm RADIX SORT. Porównaj wcześniej zaimplementowane algorytmy z RADIX SORTEM pod względem liczby wykonanych operacji, czasu działania algorytmu oraz zużycia pamięci (wykorzystaj np. <code>sysinfo</code> lub <code>GetProcessMemoryInfo</code>), dla danych o rozmiarze <span class="math inline">\(n\in \{ 10,50,100,500,1000,5000,\dots,100000 \}\)</span>, sprawdź jak na działanie RADIX SORTa wpływa zakres, z którego losowane są dane do sortowania.</p>
</blockquote>
<p><em>Jako, że jest to zadanie rozszerzające, praktycznie rzecz biorąc, całą poprzednią listę folder na zadanie 1 ma w sobie kopię całej listy 2 rozszerzonej o zadanie 1 z listy 3.</em><br />
<em>Dlatego też nazwy takie jak <code>ex-1</code> czy też <code>ex-2</code> odwołują się do odpowiednich zadań z listy 2. Mowa tutaj oczywiście tylko o plikach w folderze na zadanie 1.</em></p>
<p>W celu kompilacji programu należy użyć <code>make</code>. <em>(Możliwe jest uprzednie posprzątanie <code>make clean</code>)</em><br />
Żeby uruchomić program należy użyć <code>./main.out &lt;params&gt;</code>, gdzie <code>&lt;params&gt;</code>:</p>
<ul>
<li><code>--type</code> - uruchom program z algorytmem:</li>
<li><code>quick</code> dla <code>QuickSort</code> <em>(domyślny)</em></li>
<li><code>insert</code> dla <code>InsertSort</code></li>
<li><code>merge</code> dla <code>MergeSort</code></li>
<li><code>dual-pivot-quick</code> dla <code>DualPivotQuickSort</code></li>
<li><code>radix</code> dla <code>RadixSort</code></li>
<li><code>--comp</code> - kolejność elementów:</li>
<li><code>'&gt;='</code> malejąca</li>
<li><code>'&lt;='</code> rosnąca <em>(domyślna)</em></li>
<li><code>--stat nazwa_pliku k</code></li>
<li><code>nazwa_pliku</code> plik do którego program ma zapisać statystyki</li>
<li><code>k</code> ile razy ma wykonać pętlę opisaną w <a href="https://cs.pwr.edu.pl/golebiewski/teaching/1920/aisd/lab2.pdf">zadaniu 2 listy 2</a></li>
</ul>
<h3 id="czas-i-liczba-przestawień">Czas i liczba przestawień</h3>
<p>Poniższe wykresy pokazują, że w przypadku sortowania liczb <code>RadixSort</code> radzi sobie najlepiej w porównaniu z poprzednio zaimplementowanymi algorytmami.</p>
<p><strong>Liczba przestawień</strong><br />
<img src="ex-1/ex-2-stats/swaps-avg.png" alt="graph" /></p>
<p><strong>Czas</strong><br />
<img src="ex-1/ex-2-stats/time-avg.png" alt="graph" /></p>
<p><strong>Liczba przestawień nad <code>n</code></strong><br />
<img src="ex-1/ex-2-stats/s-over-n.png" alt="graph" /></p>
<p>gdzie: - kolor czerwony -&gt; <code>QuickSort</code> - kolor zielony -&gt; <code>DualPivotQuickSort</code> - kolor niebieski -&gt; <code>MergeSort</code> - kolor różowy -&gt; <code>RadixSort</code></p>
<h3 id="zużycie-pamięci">Zużycie pamięci</h3>
<p>Do zmierzenia ilości zużywanej pamięci wykorzystywałem programu <code>ps -p &lt;PID&gt; -o vsz</code> w celu odczytania ilości wykorzystywanej pamięci wirtualnej.<br />
Zmodyfikowałem program z listy 2 w ten sposób, żeby po jego uruchomieniu z parametrem <code>--stat</code> wyświetlał na samym początku działania swoje <code>PID</code>.</p>
<p>Program uruchamiałem z parametrem <code>k = 10</code> poszczególne algorytmy i śledziłem zużycie pamięci procesów.</p>
<p>Algorytm <code>RadixSort</code> na końcu działania zużywał aż <code>111 772 kB</code> wirtualnej pamięci (parametr VSZ).<br />
Za to <code>QuickSort</code> zużywał jedynie <code>33 716 kB</code> wirtualnej pamięci. Podobnie zachowywał się <code>DualPivotQuickSort</code> oraz <code>InsertionSort</code>.</p>
<p>Co ciekawe, zużycie pamięci w przypadku <code>MergeSort</code> rosło bardzo szybko przekraczając zużycie pamięci <code>RadixSort</code>a. Domyślam się jednak, że to wynika ze słabego działania <em>garbage collector</em>'a a nie z samego algorytmu.</p>
<p>Oczywiście w przypadku pamięci wchodzi też tutaj <em>overhead</em> w postaci innych komponentów programu, bo program nie składa się tylko z samego czystego algorytmu.<br />
Jednakże różnica jest jak najbardziej zauważalna - po wyjściu z <em>comparison model</em> uzyskujemy sortowanie w czasie liniowym, jednak tracimy na wielkości potrzebnej pamięci.</p>
<h3 id="wpływ-zakresu">Wpływ zakresu</h3>
<p>Przy zmniejszeniu zakresu, z którego są losowane liczby do sortowania następuje nawet dwukrotne zmniejszenie się liczby przestawień oraz znacznie krótszy czas działania. Dzieje się tak nawet przy ciągach bardzo dużych rozmiarów.</p>
<hr />
<h2 id="zadanie-2">Zadanie 2</h2>
<blockquote>
<p>Zaimplementuj podane na wykładzie algorytmy: RANDOMIZED SELECT, SELECT. Program przyjmuje jeden z dwóch parametrów wejściowych: - wywołanie <code>./main -r</code> oznacza operowanie na danych losowych długości <span class="math inline">\(n\)</span> - wywołanie <code>./main -p</code> oznacza operowanie na losowej permutacji zbioru <span class="math inline">\(\{1,2,\dots,n\}\)</span>. Po uruchomieniu, program wczytuje ze standardowego wejścia dwie liczby całkowite: <span class="math inline">\(n\)</span> – długość danych oraz <span class="math inline">\(1\le k \le n\)</span> – numeru szukanej statystyki pozycyjnej, a następnie generuje tablicę danych (zależnie od parametru uruchomienia) i sekwencyjnie uruchamia zaimplementowane algorytmy na wygenerowanych danych. W czasie wykonywania algorytmów SELECT, RANDOMIZED SELECT, na standardowym wyjściu błędów, powinien być wypisywany log, tak by można było działanie algorytmu odtworzyć. W szczególności powinien zawierać on tablicę danych, <span class="math inline">\(k\)</span>, kolejno wybierane pivoty, wykonywane porównania i przestawienia oraz podsumowanie zawierające liczbę porównań oraz przestawień elementów (<strong>Uwaga:</strong> w przypadkach, gdy nie jest to niezbędne dla znalezienia <span class="math inline">\(k\)</span>-tej statystyki pozycyjnej, nie powinno następować sortowanie całej tablicy).</p>
<p>Wynikiem, wyświetlanym na standardowym wyjściu, działania algorytmu jest tablica z zaznaczoną <span class="math inline">\(k\)</span>-tą statystyką pozycyjną.</p>
<p>Przykładowe wywołanie:</p>
<pre><code>./main -p
7
3
2 1 [3] 5 4 6 7</code></pre>
<p>Wykonaj testy, powtarzając wywołania algorytmów dla tych samych danych wejściowych, by wyciągnąć wnioski na temat minimalnej i maksymalnej liczby porównań dla obu algorytmów, policz również średnią i odchylenie standardowe dla zebranych statystyk.</p>
</blockquote>
<p>W celu ułatwienia korzystania z programu algorytmy nie są uruchamiane jeden po drugim, a raczej na podstawie argumentów <code>--select</code> oraz <code>--randomized-select</code>.</p>
<p>W celu uruchomienia programu należy wykonać <code>make</code> oraz <code>./main.out &lt;-p|-r&gt; &lt;--select|--randomized-select&gt;</code>.<br />
Następnie należy podać liczby <span class="math inline">\(n\)</span> oraz <span class="math inline">\(k\)</span> oddzielone spacją lub nową linijką.</p>
<h3 id="zadanie-2---statystyki">Zadanie 2 - statystyki</h3>
<p>Do skompilowania poniższych statystyk uruchamiałem program na danych <span class="math inline">\(n = 128\)</span>, <span class="math inline">\(k = 32\)</span> przy uruchamianiu programu z parametrem <code>-p</code>.</p>
<p><strong>Liczba porównań:</strong> | . | SELECT | RANDOMIZED SELECT | | ---------------------: | :----: | :---------------: | | Maximum | 840 | 606 | | Minimum | 636 | 189 | | Średnia | 751.8 | 380 | | Odchylenie standardowe | 70.153 | 147.742 |</p>
<hr />
<h2 id="zadanie-3">Zadanie 3</h2>
<blockquote>
<p>Zaimplementuj rekurencyjny algorytm wyszukiwania binarnego. Program na wejściu otrzymuje posortowaną tablicę długości <span class="math inline">\(n\)</span> oraz wartość <span class="math inline">\(v\)</span>, i zwraca <span class="math inline">\(1\)</span> w przypadku istnienia elementu <span class="math inline">\(v\)</span> w tablicy lub <span class="math inline">\(0\)</span> w przeciwnym przypadku. Przetestuj działanie Master theorem dla zliczonej w trakcie działania algorytmu liczby porównań elementów oraz czasu wykonania. Test powtórz dla <span class="math inline">\(n \in \{ 1000,2000,\dots,100000 \}\)</span> i na ich podstawie oszacuj czynnik <span class="math inline">\(O(1)\)</span> dla obu statystyk.</p>
</blockquote>
<p>W celu uruchomieniu programu należy użyć <code>./main.py</code>.</p>
<p>Program zwraca wynik testu opisany <a href="https://cs.pwr.edu.pl/golebiewski/teaching/1920/aisd/lab3.pdf">w zadaniu</a>.</p>
</body>
</html>
