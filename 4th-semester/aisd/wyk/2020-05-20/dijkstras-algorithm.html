<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title></title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="/style.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@500&display=swap" rel="stylesheet">
</head>
<body>
<hr />
<ul>
<li><a href="#concept">Concept</a></li>
<li><a href="#implementacja">Implementacja</a></li>
<li><a href="#przykład">Przykład</a></li>
<li><a href="#alternatywna-interpretacja">Alternatywna interpretacja</a></li>
<li><a href="#poprawność-działania-algorytmu">Poprawność działania algorytmu</a></li>
<li><a href="#złożoność-obliczeniowa">Złożoność obliczeniowa</a></li>
<li><a href="#more">More</a></li>
</ul>
<hr />
<h2 id="concept">Concept</h2>
<p>Algorytm Dijkstry pozwala na znajdowanie najkrótszych ścieżek w grafie <span class="math inline">\(G = (V,E,l)\)</span>, gidze <span class="math inline">\(l: E\to \mathbb{R}_+\)</span>. Jest on prostą modyfikacją procedury <a href="../2020-05-18/breadth-first-search">BFS</a> i w gruncie rzeczy polega na zastąpieniu kolejki FIFO w algorytmie BFS, kolejką priorytetową. Implementacje <a href="../2020-05-04/kolejka-priorytetowa">kolejki priorytetowej na bazie kopca minimalnego zostały przedstawione na poprzednich wykładach</a>.</p>
<h2 id="implementacja">Implementacja</h2>
<p>W algorytmie Dijkstry zostaną użyte następujące operacje na kolejce priorytetowej: - <code>MakeQueue</code><span class="math inline">\((A)\)</span> – buduje kolejkę priorytetową z wejściowej tablicy traktując odpowiednie klucze w tablicy <span class="math inline">\(A\)</span> jako priorytety (im mniejszy klucz tym wyższy priorytet). - <code>ExtractMin</code><span class="math inline">\((Q)\)</span> – zwraca i usuwa z kolejko element o najwyższym priorytecie, czyli w tym przypadku najmniejszym kluczu. - <code>DecreaseKey</code><span class="math inline">\((Q,i)\)</span> – informuje kolejkę, że element <span class="math inline">\(Q[i]\)</span> ma zmniejszony klucz i w razie potrzeby przesuwa go na odpowiednie miejsce w kolejce.</p>
<p><code>Dijkstra</code><span class="math inline">\((G,s)\)</span>: 1. <code>for all</code> <span class="math inline">\(v \in V\)</span>: 1. <span class="math inline">\(v.\mathrm{dist} \gets \infty\)</span> 2. <span class="math inline">\(v.\mathrm{prev} \gets\)</span> <code>null</code> 2. <span class="math inline">\(s.\mathrm{dist} \gets 0\)</span> 3. <span class="math inline">\(s.\mathrm{prev} \gets s\)</span> 4. <span class="math inline">\(Q \gets\)</span> <code>MakeQueue</code><span class="math inline">\((V)\)</span><br />
# używa <span class="math inline">\(v.\mathrm{dist}\)</span> jako kluczy w kolejce priorytetowej; im mniejsza wartość <span class="math inline">\(\mathrm{dist}\)</span> tym wyższy priorytet 5. <code>while</code> <span class="math inline">\(|Q| &gt; 0\)</span>: 1. <span class="math inline">\(u \gets\)</span> <code>ExtractMin</code><span class="math inline">\((Q)\)</span> 2. <code>for all</code> <span class="math inline">\((u,v) \in E\)</span> 1. <code>if</code> <span class="math inline">\(v.\mathrm{dist} &gt; u.\mathrm{dist} + l(u,v)\)</span> 1. <span class="math inline">\(v.\mathrm{dist} \gets u.\mathrm{dist} + l(u,v)\)</span> 2. <span class="math inline">\(v.\mathrm{prev} \gets u\)</span> 3. <code>DecreaseKey</code><span class="math inline">\((Q,v)\)</span></p>
<p>Dla każdego <span class="math inline">\(v\in V\)</span> algorytm Dijkstry zapisuje w <span class="math inline">\(v.\mathrm{dist}\)</span> długość najkrótszej ściezki od wierzchołka startwoeg <span class="math inline">\(s \in V\)</span> (jeśli do jakiegoś wierzchołka nie da się dojść od wierzchołka <span class="math inline">\(s\)</span> to długość ta jest ustawiona na <span class="math inline">\(\infty\)</span>). Dodatkowo, dla każdego <span class="math inline">\(v \in V\)</span> w polach <span class="math inline">\(v.\mathrm{prev}\)</span> znajduje się wierzchołek, z którego bezpośrednio dojdziemy po najkrótszej ścieżce od <span class="math inline">\(s\)</span> do <span class="math inline">\(v\)</span>. Pozwala nam to na odtworzenie najkrótszych ścieżek od <span class="math inline">\(s\)</span> do dowolnego innego wierzchołka grafu <span class="math inline">\(G\)</span> (jeśli do jakiegoś wierzchołka nie możemy dojść z <span class="math inline">\(s\)</span> to wartość <span class="math inline">\(\mathrm{prev}\)</span> pozostanie <code>null</code>em).</p>
<p>Analogia do budzików w <a href="http://algorithmics.lsi.upc.edu/docs/Dasgupta-Papadimitriou-Vazirani.pdf">książce Algorithms DPV~ Chapter 4.4.1</a></p>
<h2 id="przykład">Przykład</h2>
<div class="figure">
<img src="dijkstra-algorithm-example.png" alt="example" />
<p class="caption">example</p>
</div>
<h2 id="alternatywna-interpretacja">Alternatywna interpretacja</h2>
<p>Możemy popatrzeć na problem znajdowania najkrótszej ścieżki w grafie <span class="math inline">\(G = (V,E,l)\)</span> od wierzchołka startowego <span class="math inline">\(s \in V\)</span> jak na powiększanie podzbioru wierzchołków <span class="math inline">\(R\)</span>, dla których znamy już najkrótsze ścieżki.</p>
<ul>
<li>Początkowo <span class="math inline">\(R = s\)</span> jest zbiorem zawierającym wierzchołek startowy.</li>
<li>Powiedzmy, że w pewnym momencie mamy już jakieś wierzchołki w zbiorze <span class="math inline">\(R\)</span> i chcemy go powiększyć o kolejny wierzchołek, który należy do <span class="math inline">\(V\setminus R\)</span>. Następnym dodanym do <span class="math inline">\(R\)</span> wierzchołkiem (czyli wierzchołkiem, dla którego najkrótsza ścieżka od <span class="math inline">\(s\)</span> jest już znana) powinien być wierzchołek <span class="math inline">\(v\in V\setminus R\)</span>, którego odległość od wierzchołka startowego <span class="math inline">\(s\)</span> jest najmniejsze spośród wierzchołków należących do <span class="math inline">\(R \setminus V\)</span>. Wynika to z założenia, że wszystkie krawędzie mają dodatnią wagę i dlatego jeśli <span class="math inline">\(v \in V\setminus R\)</span> ma najmniejszą odległość od <span class="math inline">\(s\)</span> w zbiorze wierzchołków <span class="math inline">\(V\setminus R\)</span> to nie jest możliwe znalezienie krótszej ścięzki do niego przechodzącej przez inne wierzchołki należące do <span class="math inline">\(V\setminus R\)</span>.<br />
W jaki sposób zidentyfikować wierzchołke <span class="math inline">\(v\)</span>, który chcemy dodać do zbioru wierzchołków, dla którego znamy już najkrótsze ścieżki? Rozpatrzmy wierzchołek <span class="math inline">\(u\)</span>, który jest bezpośrednio przed <span class="math inline">\(v\)</span> na najkrótszej ścieżce od <span class="math inline">\(s\)</span> do <span class="math inline">\(v\)</span>. Używając założenia, że wagi krawędzi są dodatnie wiemy, że <span class="math inline">\(\mathrm{dist}(s,u) &lt; \mathrm{dist}(s,v)\)</span>. Oznacza to, że <span class="math inline">\(u\in R\)</span>, bo w przeciwnym wypadku <span class="math inline">\(v\)</span> nie byłby wierzchołkiem najbliższym wierzchołka startowego <span class="math inline">\(s\)</span> spoza zbioru <span class="math inline">\(R\)</span>. Zatem najkrótsza ścieżka od <span class="math inline">\(s\)</span> do <span class="math inline">\(v\)</span> może być wyznaczona przez przedłużenie o jedną krawędź znanej już najkrótszej ścieżki do innego wierzchołka <span class="math inline">\(u\)</span>. Zatem wiemy, że wierzchołek, który będzie dodawany do zbioru <span class="math inline">\(R\)</span> wierzchołków, dla których znamy już najkrótsze ścieżki musi mieć najmniejszą wartość <span class="math inline">\(\mathrm{dist}(s,u) + l(u,v)\)</span>.</li>
</ul>
<h2 id="poprawność-działania-algorytmu">Poprawność działania algorytmu</h2>
<p>W celu formalnego udowodnienia poprawności działania algorytmu Dijkstry powinniśmy przeprowadzić dowód indukcyjny (<a href="#alternatywna-interpretacja">opierający się na rozumowaniu z powyższych punktów</a>) z następującym założeniem indukcyjnym:<br />
Na końcu każdej iteracji pętli <code>while</code> w pseudokodzie algorytmu spełnione są następujące własności: 1. Istnieje wartość <span class="math inline">\(d\)</span>, taka że wierzchołki należące do zbioru <span class="math inline">\(R\)</span> (czyli elementy, których nie ma już w kolejce <span class="math inline">\(Q\)</span>), mają odległość <span class="math inline">\(\le d\)</span> od wierzchołka startowego <span class="math inline">\(s\)</span>. 2. Dla każdego wierzchołka <span class="math inline">\(u \in V\)</span> wartość <span class="math inline">\(u.\mathrm{dist}\)</span> jest długością najkrótszej ścieżki od <span class="math inline">\(s\)</span> do <span class="math inline">\(u\)</span>, gdzie na ścieżce tej znajdują się tylko wierzchołki należące do zbioru <span class="math inline">\(R\)</span> (jeśli taka ścieżka nei istnieje to <span class="math inline">\(u.\mathrm{dist} \gets \infty\)</span>)</p>
<h2 id="złożoność-obliczeniowa">Złożoność obliczeniowa</h2>
<ul>
<li>Na początku (pierwsza pętla <code>for</code>) inicjujemy wszystkie zmienne co będzie miało złożoność <span class="math inline">\(O(|V|)\)</span>.</li>
<li>Procedura <code>MakeQueue</code> ma złożoność obliczeniową zależącą od implementacji kolejki priorytetowej (np. wykorzystując kopce binarne i <code>BuildHeap</code> mamy złożoność <span class="math inline">\(O(|V|)\)</span>), ale ogólnie można ją ograniczyć przez <span class="math inline">\(|V| \cdot\)</span> <code>Insert</code> operacji.</li>
<li>Następnie w głównej pętli <code>while</code> wykona się <span class="math inline">\(|V|\cdot\)</span> <code>ExtractMin</code> operacji.</li>
<li>W wewnętrznej pętli <code>for</code> wykona się co najwyżej <span class="math inline">\(|V|\cdot\)</span> <code>DecreaseKey</code> operacji.</li>
</ul>
<p>Zatem w sumie dostajemy górne ograniczenie na złożoność obliczeniową w postaci <span class="math inline">\(|V|\cdot\)</span> <code>Insert</code> <span class="math inline">\(+ |V|\cdot\)</span> <code>ExtractMin</code> <span class="math inline">\(+ |E|\cdot\)</span> <code>DecreaseKey</code>.</p>
<p>Porównanie złożoności obliczeniowej algorytmu Dijkstry dla różnych implementacji kolejki priorytetowej:</p>
<table>
<colgroup>
<col width="9%" />
<col width="23%" />
<col width="23%" />
<col width="44%" />
</colgroup>
<thead>
<tr class="header">
<th>Struktura</th>
<th>Złożoność <code>ExtractMin</code></th>
<th>Złożoność <code>Insert</code> i <code>DecreaseKey</code></th>
<th>Złożoność Dijkstry</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Tablica</td>
<td><span class="math inline">\(O(\lvert V\rvert)\)</span></td>
<td><span class="math inline">\(O(1)\)</span></td>
<td><span class="math inline">\(O(\lvert V\rvert^2)\)</span></td>
</tr>
<tr class="even">
<td>Kopiec binarny</td>
<td><span class="math inline">\(O(\log \lvert V\rvert)\)</span></td>
<td><span class="math inline">\(O(\log \lvert V\rvert)\)</span></td>
<td><span class="math inline">\(O((\lvert V\rvert + \lvert E\rvert)\cdot \log\lvert V\rvert)\)</span></td>
</tr>
<tr class="odd">
<td>Kopiec <span class="math inline">\(d\)</span>-arny</td>
<td><span class="math inline">\(O\left(\frac{d\log \lvert V\rvert}{\log d}\right)\)</span></td>
<td><span class="math inline">\(O\left(\frac{d\log \lvert V\rvert}{\log d}\right)\)</span></td>
<td><span class="math inline">\(O\left((\lvert V\rvert \cdot d + \lvert E\rvert)\cdot \frac{\log \lvert V\rvert}{\log d}\right)\)</span></td>
</tr>
<tr class="even">
<td>Kopiec Fibonacciego</td>
<td><span class="math inline">\(O(\log \lvert V\rvert)\)</span></td>
<td><span class="math inline">\(O(1)\)</span> (zł. zamortyzowana)</td>
<td><span class="math inline">\(O(\lvert V\rvert \log \lvert V\rvert +\lvert E\rvert)\)</span></td>
</tr>
</tbody>
</table>
<p>Warto zauważyć, że złożoność ta ostatecznie zależy od gęstości grafu (liczby krawędzi do liczby wierzchołków). Zauważmy, że jeśli <span class="math inline">\(|E| = \Omega(|V|^2)\)</span> (graf gęsty) to implementacja kolejki priorytetowej na prostej tablicy ma asymptotycznie najlepszą złożoność. Implementacja przy pomocy kopca binarnego ma lepszą niż przy pomocy tablicy jeśli <span class="math inline">\(|E| &lt; \frac{|V|^2}{\log |V|}\)</span>. Kopiec <span class="math inline">\(d\)</span>-arny będący uogólnieniem kopca binarnego ma złożoność zależną od <span class="math inline">\(d\)</span>. Jeśli ustalimy <span class="math inline">\(d \approx \frac{|E|}{|V|}\)</span>, czyli na średni stopień wierzchołka w grafie wejściowym otrzymujemy implementację, która dla grafów gęstych (czyli takich gdzie <span class="math inline">\(|E| = \Omega(|V|^2)\)</span>) jest asymptotycznie równie dobra jak tablica (złożoność Dijkstry <span class="math inline">\(O(|V|^2)\)</span>), a dla grafów rzadkich (czyli takich gdzie <span class="math inline">\(|E| = O(|V|)\)</span>) jest asymptotycznie równie dobra jak kopiec binarny (złożoność Dijkstry <span class="math inline">\(O(|V|\log |V|)\)</span>). Dodatkowo dla grafów będących pomiędzy (czyli takich gdzie <span class="math inline">\(|E| = |V|^{1+\delta}\)</span>, <span class="math inline">\(\delta \in (0,1)\)</span>) złożoność Dijkstry wynosi asymptotycznie <span class="math inline">\(O(|E|)\)</span>, czyli jest liniowa względem wielkości grafu. W celu implementacji kolejki priorytetowej można użyć również np. kopca Fibonacciego. Asymptotyczna złożoność zamortyzowana będzie w tym przypadku najlepsza, ale należy pamiętać, że kopiec Fibonacciego jest znacznie bardziej skomplikowaną strukturą, wymaga więcej pracy podczas implementacji i w praktyce często przegrywa z prostszymi strukturami.</p>
<h2 id="more">More</h2>
<ul>
<li><a href="http://algorithmics.lsi.upc.edu/docs/Dasgupta-Papadimitriou-Vazirani.pdf">Algorithms DPV~ Chapter 4.4</a></li>
<li><a href="https://web.ist.utl.pt/~fabio.ferreira/material/asa/clrs.pdf">Introduction to Algorithms CLRS~ Chapter 24</a></li>
</ul>
</body>
</html>
