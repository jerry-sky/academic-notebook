<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="pl" xml:lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Jerry Sky" />
  <meta name="dcterms.date" content="2020-03-11" />
  <title>Mnożenie n-bitowych liczb naturalnych</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="/style.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@500&display=swap" rel="stylesheet">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Mnożenie <span class="math inline">\(n\)</span>-bitowych liczb naturalnych</h1>
<p class="author">
    <span>by </span>
    <span class="author">Jerry Sky</span>
</p>
<p class="date">2020-03-11</p>
</header>
<hr />
<ul>
<li><a href="#algorytm-mnożenia-n-bitowych-liczb-naturalnych-x-cdot-y">Algorytm mnożenia <span class="math inline">\(n\)</span>-bitowych liczb naturalnych <span class="math inline">\(x \cdot y\)</span></a></li>
<li><a href="#złożoność-obliczeniowa">Złożoność obliczeniowa</a></li>
</ul>
<hr />
<h2 id="algorytm-mnożenia-n-bitowych-liczb-naturalnych-x-cdot-y">Algorytm mnożenia <span class="math inline">\(n\)</span>-bitowych liczb naturalnych <span class="math inline">\(x \cdot y\)</span></h2>
<p>Możemy przedstawić liczby <span class="math inline">\(x\)</span> i <span class="math inline">\(y\)</span> jako ciągi binarne, które potem możemy podzielić na pół tak, że <span class="math display">\[
x = 2^{\frac{n}{2}} x_L + x_R
\\
y = 2^{\frac{n}{2}} y_L + y_R
\]</span></p>
<p>Przykładowo: <span class="math inline">\(x = (1011~0110)_2\)</span>, wówczas <span class="math inline">\(x_L = (1011)_2\)</span>, <span class="math inline">\(x_R = (0110)_2\)</span></p>
<p>Następnie zauważmy, że <span class="math inline">\(x \cdot y = 2^n x_L y_L + 2^{\frac{n}{2}} \left( x_L y_R + x_R y_L \right) + x_R y_R\)</span>.<br />
Niestety algorytm typu <a href="../2020-03-09/divide-and-conquer">Divide &amp; Conquer</a> wykorzystujący powyższy podział i połączenie pod-problemów nie ma lepszej złożoności obliczeniowej od standardowego mnożenia, czyli <span class="math inline">\(O(n^2)\)</span>. Natomiast jeśli zauważymy, że <span class="math inline">\(x_L y_R = (x_L + x_R)(y_L + y_R) - x_L y_L - x_R y_R\)</span> wtedy dostajemy trzy <span class="math inline">\(\frac{n}{2}\)</span>-bitowe <em>(a nie cztery jak wcześniej)</em> pod-problemy:<br />
<span class="math inline">\(x_L y_L\)</span>, <span class="math inline">\(x_R y_R\)</span>, <span class="math inline">\((x_L + x_R)(y_L + y_R)\)</span> co skutkuje złożonością <span class="math inline">\(O\big(n^{\log_2 3}\big)\)</span>, gdzie <span class="math inline">\(\log_2 3 \approx 1.59\)</span>.</p>
<h2 id="złożoność-obliczeniowa">Złożoność obliczeniowa</h2>
<p>Zamiast <span class="math display">\[
T(n) = \bold4 \cdot T\Big(\frac{n}{2}\Big) + O(n)
\]</span> mamy <span class="math display">\[
T(n) = \bold3 \cdot T\Big(\frac{n}{2}\Big) + O(n)
\]</span> co daje nam złożoność jedynie <span class="math inline">\(O\big(n^{1.59}\big)\)</span>.</p>
<p>Całkowity czas spędzony na poziomie <span class="math inline">\(k\)</span> w drzewie rekursji wynosi <span class="math display">\[
3^k \cdot O\Big(\frac{n}{2^k}\Big) = \Big(\frac{3}{2}\Big)^k \cdot O(n).
\]</span> ponieważ każdy pod-problem <span class="math inline">\(k\)</span> tworzy trzy pod-pod-problemy o rozmiarze <span class="math inline">\(\frac{n}{2^k}\)</span>.</p>
<p>Warto zauważyć, że <span class="math inline">\(O\big(3^{\log_2n}\big) = O\big(n^{\log_23}\big)\)</span>, ponieważ <span class="math display">\[
3^{\log_2 n} =
\Big(n^{\log_n 3} \Big)^{\log_2 n} =
n^{\log_n3~\cdot~\log_2n} =
n^{\log_2(n^{\log_n3})} =\\
n^{\log_23}.
\]</span></p>
<p>Pseudokod:</p>
<p><code>function multiply(</code><span class="math inline">\(x,y\)</span><code>)</code>:<br />
input: <span class="math inline">\(x,y \in \natnums\)</span> w kodzie binarnym o długości <span class="math inline">\(n\)</span><br />
output: <code>multiply(</code><span class="math inline">\(x,y\)</span><code>)</code><span class="math inline">\(= x \cdot y\)</span> - <span class="math inline">\(n = \max(size~of~x,~size~of~y)\)</span> - <code>if</code> <span class="math inline">\(n=1\)</span>: - <code>return</code> <span class="math inline">\(x\cdot y\)</span> - <span class="math inline">\(x_L, x_R =\)</span> <code>leftmost</code> <span class="math inline">\(\lceil \frac{n}{2}\rceil\)</span>, <code>rightmost</code> <span class="math inline">\(\lfloor\frac{n}{2}\rfloor\)</span> bits of x - <span class="math inline">\(y_L, y_R =\)</span> <code>leftmost</code> <span class="math inline">\(\lceil \frac{n}{2}\rceil\)</span>, <code>rightmost</code> <span class="math inline">\(\lfloor\frac{n}{2}\rfloor\)</span> bits of y - <span class="math inline">\(P_1 =\)</span> <code>multiply(</code><span class="math inline">\(x_L,y_L\)</span><code>)</code> - <span class="math inline">\(P_2 =\)</span> <code>multiply(</code><span class="math inline">\(x_R,y_R\)</span><code>)</code> - <span class="math inline">\(P_3 =\)</span> <code>multiply(</code><span class="math inline">\(x_L + x_R, y_L + y_R\)</span><code>)</code> - <code>return</code> <span class="math inline">\(P_1 \cdot 2^n + (P_3 - P_1 - P_2) \cdot 2^{\frac{n}{2}} + P_2\)</span></p>
<p>Source: <a href="http://algorithmics.lsi.upc.edu/docs/Dasgupta-Papadimitriou-Vazirani.pdf">Algorithms: Dasgupta, Papadimitriou, Vazirani</a> - paragraph 2.1</p>
</body>
</html>
