<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="pl" xml:lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Jerry Sky" />
  <title>Lista-3</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="/style.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@500&display=swap" rel="stylesheet">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Lista-3</h1>
<p class="author">
    <span>by </span>
    <span class="author">Jerry Sky</span>
</p>
</header>
<hr />
<ul>
<li><a href="#zadanie-1">Zadanie 1</a></li>
<li><a href="#zadanie-2">Zadanie 2</a></li>
<li><a href="#zadanie-3">Zadanie 3</a></li>
</ul>
<hr />
<blockquote>
<p>Celem listy jest praktyczne przećwiczenie metaheurystyk populacyjnych. Dobór parametrów (np. kodowanie, liczność populacji, liczba iteracji, operatory stochastyczne) należy do autora programu. W czasie rozwiązywania listy autor powinien rozpoznać jaki wpływ na działanie programu (czas działania, wymagania pamięciowe, osiągany rezultat, podatność na utknięcia w lokalnym minimum, … ) mają poszczególne parametry.</p>
</blockquote>
<h2 id="zadanie-1">Zadanie 1</h2>
<blockquote>
<p>Napisz program, który za pomocą wybranego algorytmu populacyjnego (sugerowane podejście: rój cząstek lub algorytm genetyczny z reprezentowaniem genów przez liczbę rzeczywistą) znajdzie minimum funkcji X.S. Yang zadanej wzorem <span class="math display">\[
f(\overline{x}) = \sum_{i=1}^5\mathcal{E}_i |x_i|^i
\]</span> dla <span class="math inline">\(\mathcal{E}_i\)</span> będących niezależnymi zmiennymi losowymi z rozkładu jednostajnego na <span class="math inline">\([0, 1]\)</span>.</p>
<p><strong>In</strong>: 11 liczb (6 całkowitych i 5 typu <code>double</code>) <code>t x1 x2 x3 x4 x5</code> <span class="math inline">\(\mathcal{E}_1~ \mathcal{E}_2~ \mathcal{E}_3~ \mathcal{E}_4~ \mathcal{E}_5\)</span> oddzielonych spacją.<br />
<code>t</code> – maksymalna liczba sekund, którą może wykonywać się program w tym uruchomieniu, <span class="math inline">\(\overline{x} = (\)</span><code>x1, x2, x3, x4, x5</code><span class="math inline">\()\)</span> – jest rozwiązaniem początkowym (podane liczby zawsze są całkowite, program natomiast może je interpretować jako dowolny typ liczbowy). <span class="math inline">\(\mathcal{E}_i\)</span> są współczynnikami funkcji reprezentowanymi przez liczby typu <code>double</code>.<br />
Uwaga: Dla każdego <span class="math inline">\(i\)</span> <span class="math inline">\(|x_i| \le 5\)</span>.</p>
<p><strong>Out</strong>: 6 liczb typu <code>double</code> oddzielonych spacją, z czego cztery pierwsze to <span class="math inline">\(\overline{x}\)</span>, natomiast ostatnia to wartość funkcji w punkcie <span class="math inline">\(\overline{x}\)</span>.</p>
</blockquote>
<p><a href="z1/main.py">code</a></p>
<h2 id="zadanie-2">Zadanie 2</h2>
<blockquote>
<p>Napisz program, który za pomocą algorytmu genetycznego będzie generował słowa, które można ułożyć z otrzymanego multizbioru liter, należące do załączonego słownika, maksymalizując ich punktację. Zakładamy, że w folderze bieżącym pliku main znajduje się słownik dopuszczalnych słów <a href="z2/dict.txt"><code>dict.txt</code></a> (testy mogą być prowadzone dla mniejszego słownika, nie będą prowadzone dla słownika liczniejszego od przykładowego, ograniczamy się do ASCII), który służy do weryfikacji dopuszczalności uzyskanego rozwiązania. Słowo uważane jest za niedopuszczalne również wtedy, gdy nie można go ułożyć z dostępnych liter (liczba kopii jest brana pod uwagę). Jeśli rozwiązanie jest dopuszczalne, za jego punktację przyjmujemy sumę punktów wszystkich liter, które się na nie składają.</p>
<p><strong>In</strong>: Wejście składać się będzie z <span class="math inline">\(n + s + 1\)</span> linii. W pierwszej linii znajdować się będą trzy liczby całkowite oddzielone spacjami: <code>t</code> <span class="math inline">\(n\)</span> <span class="math inline">\(s\)</span>. Liczba <code>t</code> jest ograniczeniem czasowym jak w zadaniu pierwszym, liczba <span class="math inline">\(n\)</span> określa rozmiar multizbioru liter, <span class="math inline">\(s\)</span> oznacza liczbę zadanych na wejściu rozwiązań dopuszczalnych. W kolejnych <span class="math inline">\(n\)</span> liniach znajdować się będą oddzielone spacją pary <span class="math inline">\(c_i\)</span> <span class="math inline">\(p_i\)</span>, gdzie <span class="math inline">\(c_i\)</span> jest <span class="math inline">\(i\)</span>-tym elementem multizbioru (<span class="math inline">\(i\)</span>-tą literą), natomiast <span class="math inline">\(p_i\)</span> jej wartością punktową. Można przyjąć, że wszystkie kopie tej samej litery mają identyczną wartość punktową. W <span class="math inline">\(s\)</span> ostatnich liniach znajdować się będą kolejno słowa (bez rozdzielających litery spacji) będące dopuszczalnymi rozwiązaniami dla danego wywołania.<br />
Przykładowe dane wejściowe można znaleźć <a href="z2/l3z2a.txt">tu</a> i <a href="z2/l3z2b.txt">tutaj</a>.</p>
<p><strong>Out</strong>: Na standardowym wyjściu powinna zostać zwrócona liczba całkowita będąca sumą punktów uzyskanego rozwiązania. Na standardowym wyjściu błędów powinno zostać wypisane rozwiązanie końcowe (w przypadku większej ilości informacji, słowo końcowe powinno być jedynym ciągiem znaków w ostatniej linii <code>stderr</code>).</p>
<p>Uwaga: Słownik zawsze będzie uporządkowany w kolejności alfabetycznej. W ramach preprocessingu można reorganizować słownik (np. drzewo prefiksowe) natomiast <code>t</code> jest ograniczeniem na całkowity czas działania programu.<br />
Uwaga 2: Zakładamy, że kapitalizacja liter nie ma znaczenia.</p>
</blockquote>
<p><a href="z2/main.py">code</a></p>
<h2 id="zadanie-3">Zadanie 3</h2>
<blockquote>
<p>Napisz program, który będzie symulował poruszanie się agenta po kracie (wycinek <span class="math inline">\(\mathbb{Z}^2\)</span>). Celem jest dotarcie agenta do wyznaczonego punktu, przy założeniach, że w każdym kroku może poruszyć się o <span class="math inline">\(1\)</span> w lewo, o <span class="math inline">\(1\)</span> w prawo, o <span class="math inline">\(1\)</span> w górę albo o <span class="math inline">\(1\)</span> w dół. Program powinien za pomocą symulowanego wyżarzania generować kolejne sekwencje kroków, tak by dotarcie do celu zajęło jak najmniej rund. Jeśli agent dotrze do celu przed wykonaniem wszystkich kroków, liczymy liczbę wykonanych kroków, jeśli po wykonaniu całej wygenerowanej sekwencji kroków, agent nie dotarł do celu - kontynuuje z miejsca, w którym wylądował a długość wykonanej sekwencji wlicza się do bieżącego rozwiązania albo zaczyna nową iterację.</p>
<p><strong>In</strong>: Dane wejściowe składać się będą z <span class="math inline">\(n + s + 1\)</span> linii. W pierwszej linii będą umieszczone, oddzielone spacją liczby całkowite <code>t</code>, <span class="math inline">\(n\)</span>, <span class="math inline">\(m\)</span>, <span class="math inline">\(s\)</span> i <span class="math inline">\(p\)</span> , gdzie <span class="math inline">\(t\)</span> jest limitem czasu, jak w zadaniu 1, <span class="math inline">\(n\)</span> i <span class="math inline">\(m\)</span> oznaczają wymiary kraty (odpowiednio liczba wierszy i kolumn w labiryncie, który będzie chciał opuścić agent). Liczba całkowita <span class="math inline">\(s\)</span> oznacza liczbę danych na wejściu rozwiązań początkowych, natomiast <span class="math inline">\(p \ge s\)</span> określa górne ograniczenie na liczebność populacji. W kolejnych <span class="math inline">\(n\)</span> liniach będą znajdowały się cyfry tworzące labirynt. Między cyframi nie będzie spacji. W ostatnich s liniach będą znajdować się ciągi znaków <code>U</code>, <code>D</code>, <code>R</code>, <code>L</code> prowadzące z punktu startowego do jednego z wyjść (ciągi mogą być różnej długości, mogą prowadzić do różnych wyjść). Możliwe cyfry: - 0 – standardowe, puste pole, po którym agent może się poruszać - 1 – ściana, która nie może zostać pokonana (Uwaga: ściany mogą znajdować się również wewnątrz labiryntu, nie ma wymagania by przynajmniej jednym sąsiadem <code>1</code> była <code>1</code>; ściany mogą całkowicie blokować dostęp do części labiryntu, pod warunkiem, że istnieje ścieżka z pozycji startowej agenta do przynajmniej jednego wyjścia.). - 5 – symbol agenta, oznaczający jego pozycję początkową (Uwaga: nie ma konieczności wizualizacji kolejnych kroków). - 8 – symbol wyjścia, oznaczający pozycję celu, na który agent powinien dotrzeć (Uwaga: w danej instancji może być więcej niż jeden symbol 8, nie wszystkie 8 muszą się znajdować na obrzeżu).</p>
<p>Uwaga: Agent nie zna swojej pozycji początkowej, ani pozycji celu. Można założyć, że agent potrafi rozpoznać rodzaj pola (cyfrę) swoich czterech sąsiadów oraz, że zna <span class="math inline">\(n\)</span> oraz <span class="math inline">\(m\)</span>.<br />
Przykładowe dane wejściowe można znaleźć <a href="z3/l3z3a.txt">tu</a>, <a href="z3/l3z3b.txt">tutaj</a> i <a href="z3/l3z3c.txt">tutaj</a>. Przykłady z list wcześniejszych mają inny format wejścia zatem przed użyciem na L3 muszą zostać zmodyfikowane.</p>
<p><strong>Out</strong>: Na standardowym wyjściu znaleźć się powinna jedynie łączna liczba kroków <span class="math inline">\(k\)</span> od pozycji startowej do celu, wykonana w wybranym rozwiązaniu. Ostatnią linią na standardowym wyjściu błędów powinien być <span class="math inline">\(k\)</span>–elementowy ciąg znaków <code>U</code>, <code>D</code>, <code>R</code>, <code>L</code> oznaczający kolejne wybrane kierunki w rozwiązaniu, gdzie litery kodują odpowiednio krok w górę, krok w dół, krok w prawo i krok w lewo.</p>
</blockquote>
<p><a href="z3/main.py">code</a></p>
</body>
</html>
