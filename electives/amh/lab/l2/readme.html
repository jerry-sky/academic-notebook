<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title></title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="/style.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@500&display=swap" rel="stylesheet">
</head>
<body>
<h1 id="lista-2">Lista-2</h1>
<blockquote>
<p>Celem listy jest praktyczne przećwiczenie metaheurystyk opartych na symulowanym wyżarzaniu. Dobór parametrów (np. temperatura początkowa, tempo wychładzania czy też poziom akceptacji) należy do autora programu. W czasie rozwiązywania listy autor powinien rozpoznać jaki wpływ na działanie programu (czas działania, wymagania pamięciowe, osiągany rezultat, podatność na utknięcia w lokalnym minimum, … ) mają poszczególne parametry.</p>
</blockquote>
<h2 id="zadanie-1">Zadanie 1</h2>
<blockquote>
<p>Napisz program, który za pomocą symulowanego wyżarzania znajdzie minimum funkcji Salomona zadanej wzorem <span class="math display">\[
f(\overline{x}) = 1 - \cos\left( 2\pi\sqrt{\sum_{i=1}^{4}x_i^2} \right) + 0.1\sqrt{\sum_{i=1}^{4}x_i^2}
\]</span> <strong>In</strong>: Piątka liczb całkowitych <code>t x1 x2 x3 x4</code> oddzielonych spacją.<br />
<code>t</code> – maksymalna liczba sekund, która może wykonywać się program w tym uruchomieniu, <span class="math inline">\(x =\)</span> <span class="math inline">\((\)</span><code>x1, x2, x3, x4</code><span class="math inline">\()\)</span> – jest rozwiązaniem początkowym (podane liczby zawsze są całkowite, program natomiast może je interpretować jako dowolny typ liczbowy).</p>
<p><strong>Out</strong>: 5 liczb typu <code>double</code> oddzielonych spacją, z czego cztery pierwsze to <span class="math inline">\(\overline{x}\)</span>, natomiast piąta to wartość odpowiedniej funkcji w punkcie <span class="math inline">\(\overline{x}\)</span>.</p>
</blockquote>
<p><a href="z1/main.py">code</a></p>
<h1 id="zadanie-2">Zadanie 2</h1>
<blockquote>
<p>Napisz program, który dla przedstawionej macierzy liczb całkowitych (zakres wartości między <span class="math inline">\(0\)</span> a <span class="math inline">\(255\)</span>, można przyjąć typ <code>uint8</code> lub odpowiednik) <span class="math inline">\(M\)</span>, znajdzie najbliższą macierz <span class="math inline">\(M&#39;\)</span>, spełniającą poniższe ograniczenia - wykorzystujemy co najwyżej <span class="math inline">\(8\)</span> różnych wartości liczbowych: <span class="math inline">\(0, 32, 64, 128, 160, 192, 223, 255\)</span>, - macierz wynikowa <span class="math inline">\(M&#39;\)</span> składa się z bloków <span class="math inline">\(a \times b\)</span>, takich że <span class="math inline">\(a \ge k\)</span> i <span class="math inline">\(b \ge k\)</span>, wewnątrz jednego bloku wszystkie liczby mają równą wartość, - odległość między macierzami <span class="math inline">\(M\)</span> i <span class="math inline">\(M&#39;\)</span>, rozmiaru <span class="math inline">\(n\times m\)</span>, liczymy jako <span class="math inline">\(d_{MSE}(M, M&#39;) = \frac{1}{nm}\sum_{i=1}^n\sum_{j=1}^m (M(i,j) - M&#39;(i,j))^2\)</span></p>
<p><strong>In</strong>: Dane wejściowe składać się będą z <span class="math inline">\(n+1\)</span> linii. W pierwszej linii będą umieszczone, oddzielone spacją liczby całkowite <code>t</code>, <span class="math inline">\(n\)</span>, <span class="math inline">\(m\)</span>, <span class="math inline">\(k\)</span>, gdzie <code>t</code> jest limitem czasu, jak w zadaniu 1, natomiast <span class="math inline">\(n\)</span> i <span class="math inline">\(m\)</span> oznaczają wymiary macierzy początkowej <span class="math inline">\(M\)</span>, a <span class="math inline">\(k\)</span> jest parametrem odpowiadającym za rozmiar bloków w macierzy wynikowej <span class="math inline">\(M&#39;\)</span>. W kolejnych <span class="math inline">\(n\)</span> liniach będą znajdowały się wartości kolejnego wiersza macierzy (dokładnie <span class="math inline">\(m\)</span> liczb oddzielonych spacjami). Przykładowe dane wejściowe można znaleźć <a href="z2/l2z2a.txt">tu</a> i <a href="z2/l2z2b.txt">tutaj</a>.</p>
<p><strong>Out</strong>: Na standardowym wyjściu znaleźć się powinna jedynie odległość pomiędzy <span class="math inline">\(M\)</span> a <span class="math inline">\(M&#39;\)</span>. Na standardowym wyjściu błędów powinna być jedynie macierz <span class="math inline">\(M&#39;\)</span>, przedstawiona jako <span class="math inline">\(n\)</span> wierszy, w każdym dokładnie <span class="math inline">\(m\)</span> liczb całkowitych z określonego przedziału, oddzielonych spacją.</p>
</blockquote>
<p><a href="z2/main.py">code</a></p>
<h1 id="zadanie-3">Zadanie 3</h1>
<blockquote>
<p>Napisz program, który będzie symulował poruszanie się agenta po kracie (wycinek <span class="math inline">\(\mathbb{Z}^2\)</span>). Celem jest dotarcie agenta do wyznaczonego punktu, przy założeniach, że w każdym kroku może poruszyć się o <span class="math inline">\(1\)</span> w lewo, o <span class="math inline">\(1\)</span> w prawo, o <span class="math inline">\(1\)</span> w górę albo o <span class="math inline">\(1\)</span> w dół. Program powinien za pomocą symulowanego wyżarzania generować kolejne sekwencje kroków, tak by dotarcie do celu zajęło jak najmniej rund. Jeśli agent dotrze do celu przed wykonaniem wszystkich kroków, liczymy liczbę wykonanych kroków, jeśli po wykonaniu całej wygenerowanej sekwencji kroków, agent nie dotarł do celu - kontynuuje z miejsca, w którym wylądował a długość wykonanej sekwencji wlicza się do bieżącego rozwiązania albo zaczyna nową iterację.</p>
<p><strong>In</strong>: Dane wejściowe składać się będą z <span class="math inline">\(n+1\)</span> linii. W pierwszej linii będą umieszczone, oddzielone spacją liczby całkowite <code>t</code>, <span class="math inline">\(n\)</span> i <span class="math inline">\(m\)</span>, gdzie <code>t</code> jest limitem czasu, jak w zadaniu 1, natomiast <span class="math inline">\(n\)</span> i <span class="math inline">\(m\)</span> oznaczają wymiary kraty (odpowiednio liczba wierszy i kolumn w labiryncie, który będzie chciał opuścić agent). W kolejnych <span class="math inline">\(n\)</span> liniach będą znajdowały się cyfry tworzące labirynt. Między cyframi nie będzie spacji. Możliwe cyfry: - 0 – standardowe, puste pole, po którym agent może się poruszać - 1 – ściana, która nie może zostać pokonana (Uwaga: ściany mogą znajdować się również wewnątrz labiryntu, nie ma wymagania by przynajmniej jednym sąsiadem <code>1</code> była <code>1</code>; ściany mogą całkowicie blokować dostęp do części labiryntu, pod warunkiem, że istnieje ścieżka z pozycji startowej agenta do przynajmniej jednego wyjścia.). - 5 – symbol agenta, oznaczający jego pozycję początkową (Uwaga: nie ma konieczności wizualizacji kolejnych kroków). - 8 – symbol wyjścia, oznaczający pozycję celu, na który agent powinien dotrzeć (Uwaga: w danej instancji może być więcej niż jeden symbol 8, wszystkie 8 znajdują się on na obrzeżu).</p>
<p>Uwaga: Agent nie zna swojej pozycji początkowej, ani pozycji celu. Można założyć, że agent potrafi rozpoznać rodzaj pola (cyfrę) swoich czterech sąsiadów oraz, że zna <span class="math inline">\(n\)</span> oraz <span class="math inline">\(m\)</span>. Przykładowe dane wejściowe można znaleźć <a href="z3/l2z3a.txt">tu</a>, <a href="z3/l2z3b.txt">tutaj</a> i <a href="z3/l2z3c.txt">tutaj</a>. Przykłady z <a href="../l1/readme">listy pierwszej</a> są również prawidłowymi przykładami dla listy 2.</p>
<p><strong>Out</strong>: Na standardowym wyjściu znaleźć się powinna jedynie łączna liczba kroków <span class="math inline">\(k\)</span> od pozycji startowej do celu, wykonana w wybranym rozwiązaniu. Ostatnią linią na standardowym wyjściu błędów powinien być <span class="math inline">\(k\)</span>-elementowy ciąg znaków <code>U</code>, <code>D</code>, <code>R</code>, <code>L</code> oznaczający kolejne wybrane kierunki w rozwiązaniu, gdzie litery kodują odpowiednio krok w górę, krok w dół, krok w prawo i krok w lewo.</p>
</blockquote>
<p><a href="z3/main.py">code</a></p>
</body>
</html>
