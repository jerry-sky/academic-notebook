<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title></title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="/style.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@500&display=swap" rel="stylesheet">
</head>
<body>
<h1 id="przepływy-w-sieciach-ii">Przepływy w sieciach II</h1>
<h2 id="lemat-a">Lemat A</h2>
<p>Niech <span class="math inline">\((V,E,s,t,c)\)</span> będzie siecią. Niech <span class="math inline">\(f\)</span> będzie przepływem w sieci.<br />
Niech <span class="math inline">\(X \subseteq V\)</span> będzie takim zbiorem, że <span class="math inline">\(s \in X\)</span> oraz <span class="math inline">\(t \notin X\)</span>.<br />
Wówczas <span class="math display">\[
\lVert f \rVert = \mathrm{out}_f(X) - \mathrm{in}_f(X).
\]</span></p>
<h3 id="d-d-lematu-a">D-d Lematu A</h3>
<p>Niech: - <span class="math inline">\(Y = X \setminus \{s\}\)</span> - <span class="math inline">\(a = f(\{s\}, X^\complement)\)</span> - <span class="math inline">\(b = f(\{s\}, Y)\)</span> - <span class="math inline">\(c = f(Y,\{s\})\)</span> - <span class="math inline">\(d = f(X^\complement, \{s\})\)</span> - <span class="math inline">\(e = f(Y, X^\complement)\)</span> - <span class="math inline">\(f = f(X^\complement, Y)\)</span></p>
<div class="figure">
<img src="lemat-a-d-d.png" />

</div>
<p>Wtedy: 1. <span class="math inline">\(\lVert f \rVert = (a+b) - (c+d)\)</span> 2. <span class="math inline">\(e + c = f + b\)</span> (bo <span class="math inline">\(Y \cap \{s,t\} = \emptyset\)</span>) 3. <span class="math inline">\(\mathrm{out}_f(X) - \mathrm{in}_f(X) = (a+e) - (d+f)\)</span></p>
<p>Zatem <span class="math display">\[
\lVert f \rVert = (a-d) + (b-c)
\\= (a-d) + (e-f) = (a+e) - (d+f)
\\= \mathrm{out}_f(X) - \mathrm{in}_f(X).
\]</span></p>
<h2 id="oznaczenie-1">Oznaczenie #1</h2>
<p>Przepustowością cięcia <span class="math inline">\(X\)</span> (czyli takiego zbioru wierzchołków, że <span class="math inline">\(s \in X\)</span> oraz <span class="math inline">\(t \notin X\)</span>) nazywamy liczbę <span class="math display">\[
c(X) = \sum \{c(e): \mathrm{fst}(e) \in X \land \mathrm{snd}(e) \in X^\complement \}
\]</span></p>
<h2 id="wniosek-1-lemat-b">Wniosek #1 (Lemat B)</h2>
<p>Niech <span class="math inline">\((V,E,s,t,c)\)</span> będzie siecią. Niech <span class="math inline">\(f\)</span> będzie przepływem w sieci. Niech <span class="math inline">\(X \subseteq V\)</span> będzie takim zbiorem, że <span class="math inline">\(s \in X\)</span> oraz <span class="math inline">\(t \notin X\)</span>. Wówczas <span class="math display">\[
\lVert f \rVert \le c(X)
\]</span></p>
<h3 id="d-d-lematu-b">D-d Lematu B</h3>
<p>Korzystając z <a href="#lemat-a">poprzedniego Lematu</a> mamy <span class="math display">\[
\lVert f \rVert = \mathrm{out}_f(X) - \mathrm{in}_f(X)
\\
\le \mathrm{out}_f(X) = \sum \{ f(e): \mathrm{fst}(e) \in X \land \mathrm{snd}(e) \in X^\complement \}
\\
\le \sum \{ c(e): \mathrm{fst}(e) \in X \land \mathrm{snd}(e) \in X^\complement \} = c(X)
\]</span></p>
<p><em>Uwaga: poprzedni fakt można zapisać następująco:</em> <span class="math display">\[
\max \{ \lVert f \rVert: f \text{ jest przepływem} \} \le \min \{ c(X): X \text{ jest cięciem} \}
\]</span></p>
<h2 id="twierdzenie-ford-fulkerson">Twierdzenie (Ford-Fulkerson)</h2>
<p>Niech <span class="math inline">\(\mathcal{N}\)</span> będzie siecią.<br />
Wówczas <span class="math display">\[
\max \{ \lVert f \rVert: f \text{ jest przepływem } \mathcal{N} \} = \min \{ c(X): X \text{ jest cięciem w } \mathcal{N} \}
\]</span></p>
<h3 id="d-d-twierdzenia-ford-fulkerson">D-d Twierdzenia (Ford-Fulkerson)</h3>
<p>Niech <span class="math inline">\(f\)</span> będzie przepływem o największej możliwej wartości <span class="math inline">\(\lVert f \rVert\)</span>. Niech <span class="math inline">\(X\)</span> będzie zbiorem tych wszystkich wierzchołków <span class="math inline">\(x\)</span>, że istnieje <span class="math inline">\(f\)</span>–ścieżka powiększająca od <span class="math inline">\(s\)</span> do <span class="math inline">\(x\)</span>. Wówczas <span class="math inline">\(t \notin X\)</span> (gdyby <span class="math inline">\(t \in X\)</span>, to moglibyśmy powiększyć <span class="math inline">\(f\)</span>). Jeśli <span class="math inline">\(x \in X, y \in X^\complement\)</span> oraz <span class="math inline">\((x,y) \in E\)</span>, to <span class="math inline">\(f((x,y)) = c((x,y))\)</span> (inaczej mielibyśmy <span class="math inline">\(f\)</span>–ścieżkę powiększającą od <span class="math inline">\(s\)</span> do <span class="math inline">\(y\)</span>). Podobnie, jeśli <span class="math inline">\(x \in X, y \in X^\complement\)</span> oraz <span class="math inline">\((y,x) \in E\)</span>, to <span class="math inline">\(f((y,x)) = 0\)</span> (inaczej mielibyśmy <span class="math inline">\(f\)</span>–ścieżkę powiększającą od <span class="math inline">\(s\)</span> do <span class="math inline">\(y\)</span>).<br />
Zatem <span class="math display">\[
\lVert f \rVert = \mathrm{out}_f(X) = \mathrm{in}_f(X) = c(X) - 0 = c(X)
\]</span></p>
<p>Source: Bela Bollobas, Modern Graph Theory, Springer, 1998</p>
<h2 id="metoda-forda-fulkersona">Metoda Forda-Fulkersona</h2>
<pre><code>f := 0;
WHILE istnieje f-ścieżka powiększająca
    P := jakaś ścieżka f-powiększająca;
    f := f poprawione o P
ENDWHILE</code></pre>
<p><em>Uwaga: powyższy pseudokod nazywamy metodą, a nie algorytmem, bo nie określamy jak wybierać ścieżkę <span class="math inline">\(f\)</span>–powiększającą</em></p>
<h3 id="przykład-metoda-forda-fulkersona">Przykład (Metoda Forda-Fulkersona)</h3>
<p>Przykład sieci, dla której metoda ta działa bardzo długo:</p>
<p>Rozważamy prostą sieć z czterema wierzchołkami. Zaczynamy od potoku równego zero. Rozważamy dwie ścieżki powiększające: <span class="math inline">\(P = (s,a,b,t)\)</span> oraz <span class="math inline">\(Q = (a,b,a,t)\)</span></p>
<div class="figure">
<img src="przykład-ford-fulkerson.png" alt="przykład" />
<p class="caption">przykład</p>
</div>
<p>Po tych dwóch krokach przepustowość zwiększyliśmy o <span class="math inline">\(2\)</span>. Po <span class="math inline">\(98\)</span> kolejnych krokach <span class="math inline">\(P,Q,P,Q\dots,P,Q\)</span> dojdziemy do przepływu o maksymalnej wartości równej <span class="math inline">\(200\)</span>.<br />
Zauważmy, że gdybyśmy stosowali inne ścieżki powiększające <span class="math inline">\((s,a,t)\)</span> oraz <span class="math inline">\((s,b,t)\)</span> to po dwóch krokach otrzymalibyśmy maksymalny przepływ.</p>
<h2 id="fakt-1">Fakt #1</h2>
<p>Jeśli funkcja ograniczeń przyjmuje wartości naturalne (czyli <span class="math inline">\(c \in \mathbb{N}^E\)</span>), to <a href="#metoda-forda-fulkersona">metoda Forda-Fulkersona</a> kończy swoje działanie po skończonej liczbie kroków.</p>
<h2 id="fakt-2">Fakt #2</h2>
<p>Jeśli <span class="math inline">\(c\)</span> przyjmuje wartości niewymierne, to może się zdarzyć (przy doborze „złośliwej” funkcji <span class="math inline">\(c\)</span>), że metoda ta działa nieskończenie długo i, <em>o zgrozo</em>, nawet graniczny potok nie jest najlepszy!</p>
<h2 id="algorytm-edmontona-karpa">Algorytm Edmontona-Karpa</h2>
<pre><code>f := 0
WHILE istnieje f-ścieżka powiększająca
    P := jakaś ścieżka f-powiększająca o najkrótszej (w sensie liczby wierzchołków) długości
    f := f poprawione o P
ENDWHILE</code></pre>
<h2 id="twierdzenie-2">Twierdzenie #2</h2>
<p>Algorytm Edmontona-Karpa kończy swoje działanie po skończonej liczbie kroków i zwraca przepływ o największej wartości.</p>
<h3 id="d-d-twierdzenia-2">D-d Twierdzenia #2</h3>
<ol style="list-style-type: decimal">
<li>Wprowadźmy pojęcia grafu <span class="math inline">\(f\)</span>-powiększającego: <span class="math display">\[
F_f =
\\
\{ (x,y) \in E: f((x,y)) &lt; c((x,y,)) \} \cup
\\
\cup \left\{ (x,y): (y,x) \in E \land f((y,x)) &gt; 0 \right\}
\]</span> i definiujemy <span class="math inline">\(d_f(x) = d_{G_f}(s,x)\)</span>.</li>
<li>Pokazujemy, że jeśli <span class="math inline">\(f&#39;\)</span> jest potokiem otrzymanym z potoku <span class="math inline">\(f\)</span> przez zastosowanie ścieżki powiększającej o najkrótszej długości, to <span class="math inline">\(d_f(x) \le d_{f&#39;}(x)\)</span> dla każdego wierzchołka <span class="math inline">\(x\)</span>.</li>
<li>Definiujemy pojęcie krawędzi aktywnej na ścieżce powiększającej: jest to taka krawędź, na której zmieniamy wartość potoku. Zauważamy, że na każdej ścieżce musi być krawędzi aktywna.</li>
<li>Sprawdzamy, że jeśli krawędź <span class="math inline">\(e = (x,y)\)</span> była aktywna w krokach <span class="math inline">\(i\)</span> oraz <span class="math inline">\(j\)</span> i jednocześnie <span class="math inline">\(i &lt; j\)</span> to <span class="math inline">\(d_{f_j}(x) \ge d_{f_i}(x) + 2\)</span>.</li>
<li>Wnioskujemy, że krawędź może być aktywna co najwyżej <span class="math inline">\(\frac{|V|}{2}\)</span> razy.</li>
<li>Z tego wnioskujemy, że główna pętla może być wykonywana przez co najwyżej <span class="math inline">\(\frac{|E|\cdot |V|}{2}\)</span> razy.</li>
<li>To w zasadzie wystarcza. Ale można się zastanowić nad złożonością pod-procedury wyznaczania ścieżek powiększających. Graf <span class="math inline">\(G_f\)</span> ma co najwyżej <span class="math inline">\(2|E|\)</span> krawędzi. Algorytm przeszukiwania wszerz wykonywany jest w czasie <span class="math inline">\(O(|V| + |E|)\)</span>.<br />
Zatem złożoność algorytmu można oszacować przez <span class="math inline">\(O\left(\left(|V| + |E|\right) \cdot |V| \cdot |E| \right)\)</span>. Można to zrobić lepiej – więcej w <em>source</em>. Dla nas ważne jest to, że algorytm ten działa w czasie wielomianowym od <span class="math inline">\(|V|\)</span> i <span class="math inline">\(|E|\)</span>.</li>
</ol>
<p><a href="https://web.ist.utl.pt/~fabio.ferreira/material/asa/clrs.pdf">Source: CLRS</a></p>
</body>
</html>
