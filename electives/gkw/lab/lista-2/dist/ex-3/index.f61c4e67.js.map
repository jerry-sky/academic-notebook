{"mappings":"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","sources":["./types.ts","./ex-3/shaders.ts","./ex-3/main.ts","./ex-3/canvas.ts"],"sourcesContent":["\nexport class Point3D {\n\n    constructor(\n        public x: number,\n        public y: number,\n        public z: number\n    ) { }\n\n    public static from(p: Point3D): Point3D {\n        return new Point3D(p.x, p.y, p.z)\n    }\n\n    public reset(p?: Point3D) {\n        this.x = p?.x || 0\n        this.y = p?.y || 0\n        this.z = p?.z || 0\n    }\n\n    public negate() {\n        this.x = -this.x\n        this.y = -this.y\n        this.z = -this.z\n    }\n\n    public translate(vector: Point3D) {\n        this.x += vector.x\n        this.y += vector.y\n        this.z += vector.z\n    }\n\n    public translateY(value: number) {\n        this.y += value\n    }\n\n    public scale(factor: number) {\n        this.x *= factor\n        this.y *= factor\n        this.z *= factor\n    }\n\n    /**\n     * Rotate the point around (0,0,0)\n     * looking top-down on the XY plane.\n     *\n     * The unit of the `angle` argument is degrees.\n     */\n    public rotateXY(angle: number) {\n        const sin = Math.sin(angle / 180 * Math.PI)\n        const cos = Math.cos(angle / 180 * Math.PI)\n        const newX = this.x * cos - this.y * sin\n        const newY = this.x * sin + this.y * cos\n        this.x = newX\n        this.y = newY\n    }\n\n}\n\nexport class ListOfPoint3D extends Array<Point3D> {\n\n    constructor(points?: Point3D[]) {\n        if (points)\n            super(...points)\n        else\n            super(0)\n    }\n\n    public static concatenate(...list: ListOfPoint3D[]) {\n        return new ListOfPoint3D([].concat(...list))\n    }\n\n    public get flatList() {\n\n        const flat = new Array<number>()\n\n        this.forEach((vertex) => {\n            flat.push(vertex.x)\n            flat.push(vertex.y)\n            flat.push(vertex.z)\n        });\n\n        return flat\n\n    }\n\n    public reset(p?: Point3D) {\n        const origin = Point3D.from(this[0])\n        origin.negate()\n        origin.translate(p)\n        this.forEach((vertex) => {\n            vertex.translate(origin)\n        })\n    }\n\n    public translate(vector: Point3D) {\n        this.forEach((vertex) => {\n            vertex.translate(vector)\n        })\n    }\n\n    public translateY(value: number) {\n        this.forEach((vertex) => {\n            vertex.translateY(value)\n        })\n    }\n\n    public scale(factor: number) {\n        this.forEach((vertex) => {\n            vertex.scale(factor)\n        })\n    }\n\n    /**\n     * Rotate by some amount given in degrees.\n     */\n    public rotateXY(angle: number) {\n        this.forEach((vertex) => {\n            vertex.rotateXY(angle)\n        })\n    }\n}\n","\nexport const vertexShaderRaw = {\n    source: `\nprecision mediump float;\n\nattribute vec3 vertPosition;\n\nvoid main()\n{\n    gl_Position = vec4(vertPosition, 1.0);\n    gl_PointSize = 10.0;\n}\n`,\n    attributes: {\n        vertPosition: 'vertPosition',\n    },\n}\n\nexport const fragmentShaderRaw = {\n    source: `\nprecision mediump float;\n\nuniform vec3 fragColour;\n\nvoid main()\n{\n    gl_FragColor = vec4(fragColour, 1.0);\n}\n`,\n    attributes: {},\n    uniforms: {\n        colour: 'fragColour',\n    },\n}\n","import { ListOfPoint3D, Point3D } from '../types'\nimport { MyCanvas, Shape } from './canvas'\n\nconst canvasElement: HTMLCanvasElement = document.querySelector('canvas')\n\nconst myCanvas = new MyCanvas(canvasElement)\n\nmyCanvas.startAnimationLoop()\n\n// prepare decorations\n// add a frame\nmyCanvas.addShape({\n    colour: [0.5, 0.5, 0.5],\n    drawType: myCanvas.DrawTypes.LINE_LOOP,\n    points: new ListOfPoint3D([\n        new Point3D(-1, -1, -0.5),\n        new Point3D(-1, 1, -0.5),\n        new Point3D(1, 1, -0.5),\n        new Point3D(1, -1, -0.5),\n    ])\n})\n\n// add a mother ship\nmyCanvas.addShape({\n    colour: [1, 0, 0],\n    drawType: myCanvas.DrawTypes.TRIANGLE_FAN,\n    points: new ListOfPoint3D([\n        new Point3D(-1, 0.7, -0.4),\n        new Point3D(1, 0.7, -0.4),\n        new Point3D(0.5, 0.4, -0.4),\n        new Point3D(-0.5, 0.4, -0.4),\n    ])\n})\n\n// add another piece of decoration\nconst decorSize = 0.9\nmyCanvas.addShape({\n    colour: [0.4, 0, 0.8],\n    drawType: myCanvas.DrawTypes.LINE_LOOP,\n    points: new ListOfPoint3D([\n        new Point3D(decorSize, -decorSize, -0.6),\n        new Point3D(decorSize, decorSize, -0.6),\n        new Point3D(-decorSize, decorSize, -0.6),\n        new Point3D(-decorSize, -decorSize, -0.6),\n    ])\n})\n\n// the bullet that the players uses to annihilate the opponents\nconst bulletWidth = 0.01\nconst bulletHeight = 0.1\nconst bullet: Shape = {\n    colour: [1, 1, 1],\n    drawType: myCanvas.DrawTypes.TRIANGLE_FAN,\n    points: new ListOfPoint3D([\n        new Point3D(0, 0, 0),\n        new Point3D(0, bulletHeight, 0),\n        new Point3D(bulletWidth, bulletHeight, 0),\n        new Point3D(bulletWidth, 0, 0)\n    ])\n}\nmyCanvas.addShape(bullet)\nbullet.points.translate(new Point3D(0, -2, 0.1))\n\nconst playerSize = 0.15\nconst player: Shape = {\n    colour: [1, 0, 1],\n    drawType: myCanvas.DrawTypes.TRIANGLE_FAN,\n    points: new ListOfPoint3D([\n        new Point3D(0, 0, 0),\n        new Point3D(0, playerSize, 0),\n        new Point3D(playerSize, playerSize, 0),\n        new Point3D(playerSize, 0, 0),\n    ])\n}\nmyCanvas.addShape(player)\nplayer.points.translate(new Point3D(0, -1, 0))\n\nconst opponentsInARow = 8\nconst opponentsCount = opponentsInARow * 2\nconst opponentWidth = 1 / opponentsInARow\nconst opponentHeight = 0.08\n// add opponents\nconst opponents: Shape[] = []\nfor (let i = 0; i < opponentsCount; i++) {\n    const opponent = {\n        colour: [0, 1, 0],\n        drawType: myCanvas.DrawTypes.TRIANGLE_FAN,\n        points: new ListOfPoint3D([\n            new Point3D(0, 0, 0),\n            new Point3D(0, opponentHeight, 0),\n            new Point3D(opponentWidth, opponentHeight, 0),\n            new Point3D(opponentWidth, 0, 0)\n        ])\n    }\n    opponents.push(opponent)\n    myCanvas.addShape(opponent)\n    const row = Math.floor(i / opponentsInARow)\n    opponent.points.translate(new Point3D(\n        -1 + (i - row * opponentsInARow) * opponentWidth * 2 + opponentWidth / 2,\n        row * opponentHeight * 1.2,\n        0\n    ))\n}\n\nlet bulletGoing = false\nconst bulletVelocity = 0.001\n\nlet opponentsHit = 0\n\nlet lastTime = performance.now()\nanimate(performance.now())\nfunction animate(time: number) {\n\n    const timeDelta = time - lastTime\n    lastTime = time\n\n    if (bulletGoing) {\n        bullet.points.translateY(timeDelta * bulletVelocity)\n        if (bullet.points[0].y > 1) {\n            bulletGoing = false\n        }\n\n        const bulletOrigin = bullet.points[1]\n        // check for collisions\n        for (const opponent of opponents) {\n            const origin = opponent.points[0]\n            if (\n                origin.y <= bulletOrigin.y\n                && origin.x <= bulletOrigin.x\n                && origin.x + opponentWidth >= bulletOrigin.x\n            ) {\n                bulletGoing = false\n                opponent.points.translateY(2)\n                bullet.points.translateY(2)\n                opponentsHit++\n\n                if (opponentsHit === opponentsCount) {\n                    alert('Level cleared, restart the page to play again.')\n                }\n                break\n            }\n        }\n    }\n\n    window.requestAnimationFrame(animate)\n\n}\n\nwindow.addEventListener('keydown', (event) => {\n\n    switch (event.key) {\n        case 'ArrowLeft':\n            player.points.translate(new Point3D(-0.1, 0, 0))\n            break\n        case 'ArrowRight':\n            player.points.translate(new Point3D(0.1, 0, 0))\n            break\n        case ' ': // space bar\n            // fire the bullet\n            // set the bullet’s position to that of the player’s top\n            const begin = Point3D.from(player.points[1])\n            begin.translate(new Point3D(\n                playerSize / 2 - bulletWidth / 2,\n                0,\n                0.1\n            ))\n            //. center it\n            bullet.points.reset(begin)\n            // fire it\n            bulletGoing = true\n            break\n    }\n\n})\n","import { ListOfPoint3D } from '../types';\nimport { vertexShaderRaw, fragmentShaderRaw } from './shaders'\n\nexport type Colour = number[];\n\nexport interface Shape {\n    points: ListOfPoint3D\n    drawType: number\n    colour: Colour\n}\n\nexport class MyCanvas {\n\n    /**\n     * WebGL context.\n     */\n    private gl: WebGLRenderingContext\n\n    private program: WebGLProgram\n\n    /**\n     * List of all shapes the user wants to draw.\n     */\n    private _shapes: Shape[] = []\n    public addShape(newShape: Shape) {\n        return this._shapes.push(newShape)\n    }\n    public get shapes() {\n        return this._shapes\n    }\n    public resetShapes() {\n        this._shapes = []\n    }\n\n    public readonly DrawTypes: {\n        POINTS: number,\n        LINES: number,\n        LINE_STRIP: number,\n        LINE_LOOP: number,\n        TRIANGLES: number,\n        TRIANGLE_STRIP: number,\n        TRIANGLE_FAN: number,\n    }\n\n    constructor(private canvas: HTMLCanvasElement) {\n        this.gl = this.canvas.getContext('webgl')\n\n        if (!this.gl) {\n            this.gl = this.canvas.getContext('experimental-webgl') as WebGLRenderingContext\n        }\n\n        if (!this.gl) {\n            throw new Error('WebGL not supported')\n        }\n\n        // initialize pseudo-enum containing types of primitive shapes\n        this.DrawTypes = {\n            POINTS: this.gl.POINTS,\n            LINES: this.gl.LINES,\n            LINE_STRIP: this.gl.LINE_STRIP,\n            LINE_LOOP: this.gl.LINE_LOOP,\n            TRIANGLES: this.gl.TRIANGLES,\n            TRIANGLE_STRIP: this.gl.TRIANGLE_STRIP,\n            TRIANGLE_FAN: this.gl.TRIANGLE_FAN,\n        }\n\n        this.clearScreen()\n        this.prepare()\n\n        this.gl.lineWidth(5)\n\n        // enable depth\n        this.gl.enable(this.gl.DEPTH_TEST)\n    }\n\n    private prepare() {\n        const gl = this.gl;\n        const vertexShader = this.prepareShader(vertexShaderRaw.source, gl.VERTEX_SHADER)\n        const fragmentShader = this.prepareShader(fragmentShaderRaw.source, gl.FRAGMENT_SHADER)\n\n        this.program = this.prepareProgram([vertexShader, fragmentShader])\n    }\n\n    /**\n     * Wipe the whole screen clean.\n     */\n    private clearScreen() {\n        this.gl.clearColor(0, 0, 0, 1)\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT)\n    }\n\n    private prepareShader(source: string, shaderType: number) {\n        const gl = this.gl\n\n        const shader = gl.createShader(shaderType)\n\n        gl.shaderSource(shader, source)\n        gl.compileShader(shader)\n\n        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {\n            throw new Error('Shader compilation error: ' + this.gl.getShaderInfoLog(shader))\n        }\n\n        return shader;\n    }\n\n    private prepareProgram(shaders: WebGLShader[]) {\n        const gl = this.gl;\n\n        const program = gl.createProgram()\n        shaders.forEach((shader) => {\n            gl.attachShader(program, shader)\n        });\n\n        gl.linkProgram(program)\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n            throw new Error('Program linking error: ' + this.gl.getProgramInfoLog(program))\n        }\n\n        gl.validateProgram(program)\n        if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {\n            throw new Error('Program validating error: ' + gl.getProgramInfoLog(program))\n        }\n\n        return program;\n    }\n\n    public startAnimationLoop() {\n\n        this.clearScreen()\n\n        this._shapes.forEach((shape) => {\n            this.draw3DUniformColor(shape.points, shape.drawType, shape.colour)\n        })\n\n        window.requestAnimationFrame(this.startAnimationLoop.bind(this))\n    }\n\n    private draw3DUniformColor(vertices: ListOfPoint3D, drawType: number, colour: Colour) {\n        const gl = this.gl\n\n        const vertexBuffer = gl.createBuffer()\n        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer)\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices.flatList), gl.STATIC_DRAW)\n\n        const positionAttribLocation = gl.getAttribLocation(this.program, vertexShaderRaw.attributes.vertPosition)\n\n        gl.enableVertexAttribArray(positionAttribLocation)\n        gl.vertexAttribPointer(\n            positionAttribLocation, // the vertex position attrib\n            3, // 3D\n            gl.FLOAT,\n            false,\n            3 * Float32Array.BYTES_PER_ELEMENT,\n            0 // offset equal to zero, because we’re not expecting any additional information in the given array\n        )\n\n        gl.useProgram(this.program)\n        const colourUniformLocation = gl.getUniformLocation(this.program, fragmentShaderRaw.uniforms.colour)\n        gl.uniform3fv(colourUniformLocation, new Float32Array(colour))\n\n        gl.drawArrays(drawType, 0, vertices.length)\n    }\n\n}\n"],"names":["$4637b441e76e2d234d42edafff295e88$export$Point3D","constructor","x","y","z","p","reset","this","negate","translate","vector","translateY","value","scale","factor","rotateXY","angle","sin","Math","PI","cos","newX","newY","$4637b441e76e2d234d42edafff295e88$export$ListOfPoint3D","Array","points","super","list","concat","flat","forEach","vertex","push","origin","from","$a7eb2a22ad78facc332d0e699aa31e9d$export$vertexShaderRaw","source","attributes","vertPosition","$a7eb2a22ad78facc332d0e699aa31e9d$export$fragmentShaderRaw","uniforms","colour","$0211513a17f9ec2ec9a805ccb7ff30d9$var$canvasElement","document","querySelector","$0211513a17f9ec2ec9a805ccb7ff30d9$var$myCanvas","_shapes","addShape","newShape","resetShapes","canvas","gl","getContext","Error","DrawTypes","POINTS","LINES","LINE_STRIP","LINE_LOOP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","clearScreen","prepare","lineWidth","enable","DEPTH_TEST","vertexShader","prepareShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","program","prepareProgram","clearColor","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","shaderType","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","shaders","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","validateProgram","VALIDATE_STATUS","startAnimationLoop","shape","draw3DUniformColor","drawType","window","requestAnimationFrame","bind","vertices","vertexBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","flatList","STATIC_DRAW","positionAttribLocation","getAttribLocation","enableVertexAttribArray","vertexAttribPointer","FLOAT","BYTES_PER_ELEMENT","useProgram","colourUniformLocation","getUniformLocation","uniform3fv","drawArrays","length","$0211513a17f9ec2ec9a805ccb7ff30d9$var$decorSize","$0211513a17f9ec2ec9a805ccb7ff30d9$var$bulletWidth","$0211513a17f9ec2ec9a805ccb7ff30d9$var$bullet","$0211513a17f9ec2ec9a805ccb7ff30d9$var$playerSize","$0211513a17f9ec2ec9a805ccb7ff30d9$var$player","$0211513a17f9ec2ec9a805ccb7ff30d9$var$opponentWidth","$0211513a17f9ec2ec9a805ccb7ff30d9$var$opponentHeight","$0211513a17f9ec2ec9a805ccb7ff30d9$var$opponents","i","$0211513a17f9ec2ec9a805ccb7ff30d9$var$opponentsInARow","opponent","row","floor","$0211513a17f9ec2ec9a805ccb7ff30d9$var$bulletGoing","$0211513a17f9ec2ec9a805ccb7ff30d9$var$opponentsHit","$0211513a17f9ec2ec9a805ccb7ff30d9$var$lastTime","performance","now","$0211513a17f9ec2ec9a805ccb7ff30d9$var$animate","time","timeDelta","bulletOrigin","alert","addEventListener","event","key","begin"],"version":3,"file":"index.f61c4e67.js.map"}