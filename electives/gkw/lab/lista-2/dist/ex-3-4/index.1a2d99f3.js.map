{"mappings":"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","sources":["./types.ts","./ex-3-4/shaders.ts","./ex-3-4/canvas.ts","./ex-3-4/main.ts"],"sourcesContent":["\nexport class Point3D {\n\n    constructor(\n        public x: number,\n        public y: number,\n        public z: number\n    ) { }\n\n    public static from(p: Point3D): Point3D {\n        return new Point3D(p.x, p.y, p.z)\n    }\n\n    public reset(p?: Point3D) {\n        this.x = p?.x || 0\n        this.y = p?.y || 0\n        this.z = p?.z || 0\n    }\n\n    public negate() {\n        this.x = -this.x\n        this.y = -this.y\n        this.z = -this.z\n    }\n\n    public translate(vector: Point3D) {\n        this.x += vector.x\n        this.y += vector.y\n        this.z += vector.z\n    }\n\n    public translateY(value: number) {\n        this.y += value\n    }\n\n    public scale(factor: number) {\n        this.x *= factor\n        this.y *= factor\n        this.z *= factor\n    }\n\n    /**\n     * Rotate the point around (0,0,0)\n     * looking top-down on the XY plane.\n     *\n     * The unit of the `angle` argument is degrees.\n     */\n    public rotateXY(angle: number) {\n        const sin = Math.sin(angle / 180 * Math.PI)\n        const cos = Math.cos(angle / 180 * Math.PI)\n        const newX = this.x * cos - this.y * sin\n        const newY = this.x * sin + this.y * cos\n        this.x = newX\n        this.y = newY\n    }\n\n}\n\nexport class ListOfPoint3D extends Array<Point3D> {\n\n    constructor(points?: Point3D[]) {\n        if (points)\n            super(...points)\n        else\n            super(0)\n    }\n\n    public static concatenate(...list: ListOfPoint3D[]) {\n        return new ListOfPoint3D([].concat(...list))\n    }\n\n    public get flatList() {\n\n        const flat = new Array<number>()\n\n        this.forEach((vertex) => {\n            flat.push(vertex.x)\n            flat.push(vertex.y)\n            flat.push(vertex.z)\n        });\n\n        return flat\n\n    }\n\n    public reset(p?: Point3D) {\n        const origin = Point3D.from(this[0])\n        origin.negate()\n        origin.translate(p)\n        this.forEach((vertex) => {\n            vertex.translate(origin)\n        })\n    }\n\n    public translate(vector: Point3D) {\n        this.forEach((vertex) => {\n            vertex.translate(vector)\n        })\n    }\n\n    public translateY(value: number) {\n        this.forEach((vertex) => {\n            vertex.translateY(value)\n        })\n    }\n\n    public scale(factor: number) {\n        this.forEach((vertex) => {\n            vertex.scale(factor)\n        })\n    }\n\n    /**\n     * Rotate by some amount given in degrees.\n     */\n    public rotateXY(angle: number) {\n        this.forEach((vertex) => {\n            vertex.rotateXY(angle)\n        })\n    }\n}\n","\nexport const vertexShaderRaw = {\n    source: `\nprecision mediump float;\n\nattribute vec3 vertPosition;\n\nvoid main()\n{\n    gl_Position = vec4(vertPosition, 1.0);\n    gl_PointSize = 10.0;\n}\n`,\n    attributes: {\n        vertPosition: 'vertPosition',\n    },\n}\n\nexport const fragmentShaderRaw = {\n    source: `\nprecision mediump float;\n\nuniform vec3 fragColour;\n\nvoid main()\n{\n    gl_FragColor = vec4(fragColour, 1.0);\n}\n`,\n    attributes: {},\n    uniforms: {\n        colour: 'fragColour',\n    },\n}\n\nexport const vertexTextureShaderRaw = {\n    source: `\nprecision mediump float;\n\nattribute vec3 vertPosition;\nattribute vec2 vertTextureCoordinate;\n\nvarying vec2 fragmentTextureCoordinate;\n\nvoid main()\n{\n    gl_Position = vec4(vertPosition, 1.0);\n    fragmentTextureCoordinate = vertTextureCoordinate;\n}\n`,\n    attributes: {\n        vertPosition: 'vertPosition',\n        vertTextureCoordinate: 'vertTextureCoordinate'\n    },\n}\n\nexport const fragmentTextureShaderRaw = {\n    source: `\nprecision mediump float;\n\nuniform sampler2D sampler;\n\nvarying vec2 fragmentTextureCoordinate;\n\nvoid main()\n{\n    gl_FragColor = texture2D(sampler, fragmentTextureCoordinate);\n}\n`,\n    attributes: {},\n    uniforms: {\n        colour: 'sampler',\n    },\n}\n","import { ListOfPoint3D, Point3D } from '../types';\nimport { vertexShaderRaw, fragmentShaderRaw, vertexTextureShaderRaw, fragmentTextureShaderRaw } from './shaders'\n\nexport type Colour = number[];\n\nexport interface Shape {\n    points: ListOfPoint3D\n    drawType: number\n    colour: Colour\n}\n\nexport interface TextureSquare {\n    origin: Point3D\n    size: number\n    texture: HTMLImageElement\n}\n\nexport class MyCanvas {\n\n    /**\n     * WebGL context.\n     */\n    private gl: WebGLRenderingContext\n\n    private program: WebGLProgram\n    private programTex: WebGLProgram\n\n    /**\n     * List of all shapes the user wants to draw.\n     */\n    private _shapes: Shape[] = []\n    public addShape(newShape: Shape) {\n        return this._shapes.push(newShape)\n    }\n    public get shapes() {\n        return this._shapes\n    }\n    public resetShapes() {\n        this._shapes = []\n    }\n\n    private _textureSquares: TextureSquare[] = []\n    public addTextureSquare(newSquare: TextureSquare) {\n        return this._textureSquares.push(newSquare)\n    }\n    public get textureSquares() {\n        return this._textureSquares\n    }\n\n    public readonly DrawTypes: {\n        POINTS: number,\n        LINES: number,\n        LINE_STRIP: number,\n        LINE_LOOP: number,\n        TRIANGLES: number,\n        TRIANGLE_STRIP: number,\n        TRIANGLE_FAN: number,\n    }\n\n    constructor(private canvas: HTMLCanvasElement) {\n        this.gl = this.canvas.getContext('webgl')\n\n        if (!this.gl) {\n            this.gl = this.canvas.getContext('experimental-webgl') as WebGLRenderingContext\n        }\n\n        if (!this.gl) {\n            throw new Error('WebGL not supported')\n        }\n\n        // initialize pseudo-enum containing types of primitive shapes\n        this.DrawTypes = {\n            POINTS: this.gl.POINTS,\n            LINES: this.gl.LINES,\n            LINE_STRIP: this.gl.LINE_STRIP,\n            LINE_LOOP: this.gl.LINE_LOOP,\n            TRIANGLES: this.gl.TRIANGLES,\n            TRIANGLE_STRIP: this.gl.TRIANGLE_STRIP,\n            TRIANGLE_FAN: this.gl.TRIANGLE_FAN,\n        }\n\n        this.clearScreen()\n        this.prepare()\n\n        this.gl.lineWidth(5)\n\n        // enable depth\n        this.gl.enable(this.gl.DEPTH_TEST)\n        // this.gl.enable(this.gl.CULL_FACE)\n        // this.gl.frontFace(this.gl.CCW)\n        this.gl.cullFace(this.gl.BACK)\n    }\n\n    private prepare() {\n        const gl = this.gl;\n\n        const vertexShader = this.prepareShader(vertexShaderRaw.source, gl.VERTEX_SHADER)\n        const fragmentShader = this.prepareShader(fragmentShaderRaw.source, gl.FRAGMENT_SHADER)\n        this.program = this.prepareProgram([vertexShader, fragmentShader])\n\n        const vertexTextureShader = this.prepareShader(vertexTextureShaderRaw.source, gl.VERTEX_SHADER)\n        const fragmentTextureShader = this.prepareShader(fragmentTextureShaderRaw.source, gl.FRAGMENT_SHADER)\n        this.programTex = this.prepareProgram([vertexTextureShader, fragmentTextureShader])\n    }\n\n    /**\n     * Wipe the whole screen clean.\n     */\n    private clearScreen() {\n        this.gl.clearColor(0, 0, 0, 1)\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT)\n    }\n\n    private prepareShader(source: string, shaderType: number) {\n        const gl = this.gl\n\n        const shader = gl.createShader(shaderType)\n\n        gl.shaderSource(shader, source)\n        gl.compileShader(shader)\n\n        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {\n            throw new Error('Shader compilation error: ' + this.gl.getShaderInfoLog(shader))\n        }\n\n        return shader;\n    }\n\n    private prepareProgram(shaders: WebGLShader[]) {\n        const gl = this.gl;\n\n        const program = gl.createProgram()\n        shaders.forEach((shader) => {\n            gl.attachShader(program, shader)\n        });\n\n        gl.linkProgram(program)\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n            throw new Error('Program linking error: ' + this.gl.getProgramInfoLog(program))\n        }\n\n        gl.validateProgram(program)\n        if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)) {\n            throw new Error('Program validating error: ' + gl.getProgramInfoLog(program))\n        }\n\n        return program;\n    }\n\n    public startAnimationLoop() {\n\n        this.clearScreen()\n\n        this._textureSquares.forEach((square) => {\n            this.drawTexturedSquare(square.origin, square.size, square.texture)\n        })\n\n        this._shapes.forEach((shape) => {\n            this.draw3DUniformColor(shape.points, shape.drawType, shape.colour)\n        })\n\n        window.requestAnimationFrame(this.startAnimationLoop.bind(this))\n    }\n\n    private draw3DUniformColor(vertices: ListOfPoint3D, drawType: number, colour: Colour) {\n        const gl = this.gl\n\n        const vertexBuffer = gl.createBuffer()\n        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer)\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices.flatList), gl.STATIC_DRAW)\n\n        const positionAttribLocation = gl.getAttribLocation(this.program, vertexShaderRaw.attributes.vertPosition)\n\n        gl.enableVertexAttribArray(positionAttribLocation)\n        gl.vertexAttribPointer(\n            positionAttribLocation, // the vertex position attrib\n            3, // 3D\n            gl.FLOAT,\n            false,\n            3 * Float32Array.BYTES_PER_ELEMENT,\n            0 // offset equal to zero, because we’re not expecting any additional information in the given array\n        )\n\n        gl.useProgram(this.program)\n        const colourUniformLocation = gl.getUniformLocation(this.program, fragmentShaderRaw.uniforms.colour)\n        gl.uniform3fv(colourUniformLocation, new Float32Array(colour))\n\n        gl.drawArrays(drawType, 0, vertices.length)\n    }\n\n    private drawTexturedSquare(origin: Point3D, size: number, textureSource: HTMLImageElement) {\n        const gl = this.gl\n\n        const ox = origin.x\n        const oy = origin.y\n        const oz = origin.z\n        // generate a square anchored in the `origin` point\n        const vertices = [\n            // X, Y, Z, U, V\n            ox, oy, oz, 0, 1,\n            ox, oy + size, oz, 0, 0,\n            ox + size, oy + size, oz, 1, 0,\n            ox + size, oy, oz, 1, 1\n        ]\n\n        const vertexBuffer = gl.createBuffer()\n        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer)\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW)\n\n        const positionAttribLocation =\n            gl.getAttribLocation(this.programTex, vertexTextureShaderRaw.attributes.vertPosition)\n        const textureCoordinateAttribLocation\n            = gl.getAttribLocation(this.programTex, vertexTextureShaderRaw.attributes.vertTextureCoordinate)\n\n        gl.vertexAttribPointer(\n            positionAttribLocation, // the vertex position attrib\n            3, // 3D\n            gl.FLOAT,\n            false,\n            5 * Float32Array.BYTES_PER_ELEMENT,\n            0\n        )\n        gl.vertexAttribPointer(\n            textureCoordinateAttribLocation,\n            2,\n            gl.FLOAT,\n            false,\n            5 * Float32Array.BYTES_PER_ELEMENT,\n            3 * Float32Array.BYTES_PER_ELEMENT // to get the UV coordinates we skip the XYZ coordinates\n        )\n        gl.enableVertexAttribArray(positionAttribLocation)\n        gl.enableVertexAttribArray(textureCoordinateAttribLocation)\n\n        const texture = gl.createTexture()\n        gl.bindTexture(gl.TEXTURE_2D, texture)\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        gl.texImage2D(\n            gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,\n            gl.UNSIGNED_BYTE,\n            textureSource\n        )\n\n        gl.useProgram(this.programTex)\n\n        gl.activeTexture(gl.TEXTURE0)\n\n        gl.drawArrays(gl.TRIANGLE_FAN, 0, vertices.length/5)\n    }\n\n}\n","import { ListOfPoint3D, Point3D } from '../types'\nimport { MyCanvas, Shape, TextureSquare } from './canvas'\n\n(async () => {\n\n    const imageLoader = (imageSrc: string) => new Promise<HTMLImageElement>((resolve) => {\n        const img = new Image()\n        img.addEventListener('load', () => resolve(img))\n        img.src = imageSrc\n    })\n\n    const canvasElement: HTMLCanvasElement = document.querySelector('canvas')\n\n    // load the player’s avatar\n    const playerTexture = await imageLoader(\n        (document.querySelector('img#avatar') as HTMLImageElement).src\n    )\n    // load the background image\n    const backgroundTexture = await imageLoader(\n        (document.querySelector('img#background') as HTMLImageElement).src\n    )\n\n    const myCanvas = new MyCanvas(canvasElement)\n\n    myCanvas.startAnimationLoop()\n\n    // prepare decorations\n    // add a background\n    myCanvas.addTextureSquare({\n        origin: new Point3D(-1, -1, 0.9),\n        size: 2,\n        texture: backgroundTexture\n    })\n    // add a frame\n    myCanvas.addShape({\n        colour: [0.5, 0.5, 0.5],\n        drawType: myCanvas.DrawTypes.LINE_LOOP,\n        points: new ListOfPoint3D([\n            new Point3D(-1, -1, -0.9),\n            new Point3D(-1, 1, -0.9),\n            new Point3D(1, 1, -0.9),\n            new Point3D(1, -1, -0.9),\n        ])\n    })\n\n    // add a mother ship\n    myCanvas.addShape({\n        colour: [1, 0, 0],\n        drawType: myCanvas.DrawTypes.TRIANGLE_FAN,\n        points: new ListOfPoint3D([\n            new Point3D(-1, 0.7, -0.4),\n            new Point3D(1, 0.7, -0.4),\n            new Point3D(0.5, 0.4, -0.4),\n            new Point3D(-0.5, 0.4, -0.4),\n        ])\n    })\n\n    // add another piece of decoration\n    const decorSize = 0.9\n    myCanvas.addShape({\n        colour: [0.4, 0, 0.8],\n        drawType: myCanvas.DrawTypes.LINE_LOOP,\n        points: new ListOfPoint3D([\n            new Point3D(decorSize, -decorSize, -0.6),\n            new Point3D(decorSize, decorSize, -0.6),\n            new Point3D(-decorSize, decorSize, -0.6),\n            new Point3D(-decorSize, -decorSize, -0.6),\n        ])\n    })\n\n    // the bullet that the players uses to annihilate the opponents\n    const bulletWidth = 0.01\n    const bulletHeight = 0.1\n    const bullet: Shape = {\n        colour: [1, 1, 1],\n        drawType: myCanvas.DrawTypes.TRIANGLE_FAN,\n        points: new ListOfPoint3D([\n            new Point3D(0, 0, 0),\n            new Point3D(0, bulletHeight, 0),\n            new Point3D(bulletWidth, bulletHeight, 0),\n            new Point3D(bulletWidth, 0, 0)\n        ])\n    }\n    myCanvas.addShape(bullet)\n    bullet.points.translate(new Point3D(0, -2, 0.1))\n\n    const playerSize = 0.15\n    const player: TextureSquare = {\n        origin: new Point3D(0, 0, -0.5),\n        size: playerSize,\n        texture: playerTexture\n    }\n    myCanvas.addTextureSquare(player)\n    player.origin.translate(new Point3D(0, -1, 0))\n\n    const opponentsInARow = 8\n    const opponentsCount = opponentsInARow * 2\n    const opponentWidth = 1 / opponentsInARow\n    const opponentHeight = 0.08\n    // add opponents\n    const opponents: Shape[] = []\n    for (let i = 0; i < opponentsCount; i++) {\n        const opponent = {\n            colour: [0, 1, 0],\n            drawType: myCanvas.DrawTypes.TRIANGLE_FAN,\n            points: new ListOfPoint3D([\n                new Point3D(0, 0, 0),\n                new Point3D(0, opponentHeight, 0),\n                new Point3D(opponentWidth, opponentHeight, 0),\n                new Point3D(opponentWidth, 0, 0)\n            ])\n        }\n        opponents.push(opponent)\n        myCanvas.addShape(opponent)\n        const row = Math.floor(i / opponentsInARow)\n        opponent.points.translate(new Point3D(\n            -1 + (i - row * opponentsInARow) * opponentWidth * 2 + opponentWidth / 2,\n            row * opponentHeight * 1.2,\n            0\n        ))\n    }\n\n    let bulletGoing = false\n    const bulletVelocity = 0.001\n\n    let opponentsHit = 0\n\n    let lastTime = performance.now()\n    animate(performance.now())\n    function animate(time: number) {\n\n        const timeDelta = time - lastTime\n        lastTime = time\n\n        if (bulletGoing) {\n            bullet.points.translateY(timeDelta * bulletVelocity)\n            if (bullet.points[0].y > 1) {\n                bulletGoing = false\n            }\n\n            const bulletOrigin = bullet.points[1]\n            // check for collisions\n            for (const opponent of opponents) {\n                const origin = opponent.points[0]\n                if (\n                    origin.y <= bulletOrigin.y\n                    && origin.x <= bulletOrigin.x\n                    && origin.x + opponentWidth >= bulletOrigin.x\n                ) {\n                    bulletGoing = false\n                    opponent.points.translateY(2)\n                    bullet.points.translateY(2)\n                    opponentsHit++\n\n                    if (opponentsHit === opponentsCount) {\n                        alert('Level cleared. Reload the page to play again.')\n                    }\n                    break\n                }\n            }\n        }\n\n        window.requestAnimationFrame(animate)\n\n    }\n\n    window.addEventListener('keydown', (event) => {\n\n        switch (event.key) {\n            case 'ArrowLeft':\n                player.origin.translate(new Point3D(-0.1, 0, 0))\n                break\n            case 'ArrowRight':\n                player.origin.translate(new Point3D(0.1, 0, 0))\n                break\n            case ' ': // space bar\n                // fire the bullet\n                // set the bullet’s position to that of the player’s top\n                const begin = Point3D.from(player.origin)\n                begin.translate(new Point3D(\n                    playerSize / 2 - bulletWidth / 2,\n                    0,\n                    0.1\n                ))\n                //. center it\n                bullet.points.reset(begin)\n                // fire it\n                bulletGoing = true\n                break\n        }\n\n    })\n\n})()\n"],"names":["$4637b441e76e2d234d42edafff295e88$export$Point3D","constructor","x","y","z","p","reset","this","negate","translate","vector","translateY","value","scale","factor","rotateXY","angle","sin","Math","PI","cos","newX","newY","$4637b441e76e2d234d42edafff295e88$export$ListOfPoint3D","Array","points","super","list","concat","flat","forEach","vertex","push","origin","from","$e3a98e3effa725e432e6d73993610550$export$vertexShaderRaw","source","attributes","vertPosition","$e3a98e3effa725e432e6d73993610550$export$fragmentShaderRaw","uniforms","colour","$e3a98e3effa725e432e6d73993610550$export$vertexTextureShaderRaw","vertTextureCoordinate","$e3a98e3effa725e432e6d73993610550$export$fragmentTextureShaderRaw","$f4da9fc1ea054433b393207c731ede9d$export$MyCanvas","_shapes","addShape","newShape","resetShapes","_textureSquares","addTextureSquare","newSquare","canvas","gl","getContext","Error","DrawTypes","POINTS","LINES","LINE_STRIP","LINE_LOOP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","clearScreen","prepare","lineWidth","enable","DEPTH_TEST","cullFace","BACK","vertexShader","prepareShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","program","prepareProgram","vertexTextureShader","fragmentTextureShader","programTex","clearColor","clear","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","shaderType","shader","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","shaders","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","validateProgram","VALIDATE_STATUS","startAnimationLoop","square","drawTexturedSquare","size","texture","shape","draw3DUniformColor","drawType","window","requestAnimationFrame","bind","vertices","vertexBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","flatList","STATIC_DRAW","positionAttribLocation","getAttribLocation","enableVertexAttribArray","vertexAttribPointer","FLOAT","BYTES_PER_ELEMENT","useProgram","colourUniformLocation","getUniformLocation","uniform3fv","drawArrays","length","textureSource","ox","oy","oz","textureCoordinateAttribLocation","createTexture","bindTexture","TEXTURE_2D","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","LINEAR","TEXTURE_MAG_FILTER","texImage2D","RGBA","UNSIGNED_BYTE","activeTexture","TEXTURE0","imageLoader","imageSrc","Promise","resolve","img","Image","addEventListener","src","canvasElement","document","querySelector","playerTexture","backgroundTexture","myCanvas","decorSize","bulletWidth","bullet","player","opponentWidth","opponentHeight","opponents","i","opponentsInARow","opponent","row","floor","bulletGoing","opponentsHit","lastTime","performance","now","animate","time","timeDelta","bulletOrigin","alert","event","key","begin","playerSize"],"version":3,"file":"index.1a2d99f3.js.map"}