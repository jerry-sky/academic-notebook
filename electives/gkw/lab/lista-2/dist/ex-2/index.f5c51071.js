!function(){class t{constructor(t,e,r){this.x=t,this.y=e,this.z=r}static from(e){return new t(e.x,e.y,e.z)}reset(t){this.x=t?.x||0,this.y=t?.y||0,this.z=t?.z||0}negate(){this.x=-this.x,this.y=-this.y,this.z=-this.z}translate(t){this.x+=t.x,this.y+=t.y,this.z+=t.z}translateY(t){this.y+=t}scale(t){this.x*=t,this.y*=t,this.z*=t}rotateXY(t){const e=Math.sin(t/180*Math.PI),r=Math.cos(t/180*Math.PI),a=this.x*r-this.y*e,s=this.x*e+this.y*r;this.x=a,this.y=s}}class e extends Array{constructor(t){t?super(...t):super(0)}static concatenate(...t){return new e([].concat(...t))}get flatList(){const t=new Array;return this.forEach((e=>{t.push(e.x),t.push(e.y),t.push(e.z)})),t}reset(e){const r=t.from(this[0]);r.negate(),r.translate(e),this.forEach((t=>{t.translate(r)}))}translate(t){this.forEach((e=>{e.translate(t)}))}translateY(t){this.forEach((e=>{e.translateY(t)}))}scale(t){this.forEach((e=>{e.scale(t)}))}rotateXY(t){this.forEach((e=>{e.rotateXY(t)}))}}const r={source:"\nprecision mediump float;\n\nattribute vec3 vertPosition;\n\nvoid main()\n{\n    gl_Position = vec4(vertPosition, 1.0);\n    gl_PointSize = 10.0;\n}\n",attributes:{vertPosition:"vertPosition"}},a={source:"\nprecision mediump float;\n\nuniform vec3 fragColour;\n\nvoid main()\n{\n    gl_FragColor = vec4(fragColour, 1.0);\n}\n",attributes:{},uniforms:{colour:"fragColour"}};function s(r,a){if(1===r)return new e([new t(-1,0,a),new t(-1/3,0,a),new t(0,Math.sqrt(3)/3,a),new t(1/3,0,a),new t(1,0,a)]);{const n=s(r-1,a);n.scale(1/3),n.translate(new t(-2/3,0,0));const o=s(r-1,a);o.translate(new t(1,0,0)),o.rotateXY(60),o.translate(new t(-1,0,0)),o.scale(1/3);const i=s(r-1,a);i.translate(new t(1,0,0)),i.rotateXY(-60),i.translate(new t(0,Math.sqrt(3),0)),i.scale(1/3);const l=s(r-1,a);return l.translate(new t(2,0,0)),l.scale(1/3),e.concatenate(n,o,i,l)}}function n(r,a){const n=s(r,a);n.translate(new t(0,1,0));const o=s(r,a);o.translate(new t(1,0,0)),o.rotateXY(-120),o.translate(new t(1,1,0));const i=s(r,a);i.translate(new t(1,0,0)),i.rotateXY(120),i.translate(new t(0,-5*Math.sqrt(3)/12,0));return e.concatenate(n,o,i)}function o(r,a){if(1===r)return new e([new t(-1,-1,a),new t(0,Math.sqrt(3)-1,a),new t(1,-1,a)]);{const s=o(r-1,a);s.translate(new t(-1,-1,0)),s.scale(.5);const n=o(r-1,a);n.translate(new t(1,1,0)),n.scale(.5),n.translate(new t(-.5,.5*Math.sqrt(3)-1,0));const i=o(r-1,a);i.translate(new t(1,1,0)),i.scale(.5),i.translate(new t(0,-1,0));return e.concatenate(s,n,i)}}const i=document.querySelector("canvas"),l=document.querySelector("form"),h=document.querySelector("select"),c=document.querySelector("#colour-input"),u=document.querySelector("#level-input"),p=new class{shapes=[];addShape(t){this.shapes.push(t)}get lastAddedShape(){return this.shapes.length>0?this.shapes[this.shapes.length-1]:null}constructor(t){if(this.canvas=t,this.gl=this.canvas.getContext("webgl"),this.gl||(this.gl=this.canvas.getContext("experimental-webgl")),!this.gl)throw new Error("WebGL not supported");this.DrawTypes={POINTS:this.gl.POINTS,LINES:this.gl.LINES,LINE_STRIP:this.gl.LINE_STRIP,LINE_LOOP:this.gl.LINE_LOOP,TRIANGLES:this.gl.TRIANGLES,TRIANGLE_STRIP:this.gl.TRIANGLE_STRIP,TRIANGLE_FAN:this.gl.TRIANGLE_FAN},this.clearScreen(),this.prepare(),this.gl.lineWidth(4),this.gl.enable(this.gl.DEPTH_TEST)}prepare(){const t=this.gl,e=this.prepareShader(r.source,t.VERTEX_SHADER),s=this.prepareShader(a.source,t.FRAGMENT_SHADER);this.program=this.prepareProgram([e,s])}clearScreen(){this.gl.clearColor(0,0,0,1),this.gl.clear(this.gl.COLOR_BUFFER_BIT|this.gl.DEPTH_BUFFER_BIT)}prepareShader(t,e){const r=this.gl,a=r.createShader(e);if(r.shaderSource(a,t),r.compileShader(a),!this.gl.getShaderParameter(a,this.gl.COMPILE_STATUS))throw new Error("Shader compilation error: "+this.gl.getShaderInfoLog(a));return a}prepareProgram(t){const e=this.gl,r=e.createProgram();if(t.forEach((t=>{e.attachShader(r,t)})),e.linkProgram(r),!e.getProgramParameter(r,e.LINK_STATUS))throw new Error("Program linking error: "+this.gl.getProgramInfoLog(r));if(e.validateProgram(r),!e.getProgramParameter(r,e.VALIDATE_STATUS))throw new Error("Program validating error: "+e.getProgramInfoLog(r));return r}startAnimationLoop(){this.clearScreen(),this.shapes.forEach((t=>{this.draw3DUniformColor(t.points,t.drawType,t.colour)})),window.requestAnimationFrame(this.startAnimationLoop.bind(this))}draw3DUniformColor(t,e,s){const n=this.gl,o=n.createBuffer();n.bindBuffer(n.ARRAY_BUFFER,o),n.bufferData(n.ARRAY_BUFFER,new Float32Array(t.flatList),n.STATIC_DRAW);const i=n.getAttribLocation(this.program,r.attributes.vertPosition);n.enableVertexAttribArray(i),n.vertexAttribPointer(i,3,n.FLOAT,!1,3*Float32Array.BYTES_PER_ELEMENT,0),n.useProgram(this.program);const l=n.getUniformLocation(this.program,a.uniforms.colour);n.uniform3fv(l,new Float32Array(s)),n.drawArrays(e,0,t.length)}}(i);p.startAnimationLoop(),l.onsubmit=t=>{t.preventDefault();const e=h.value,r=parseInt(u.value),a=c.value.replace(/\s+/g,"").split(",").map((t=>parseFloat(t)));if(3!==a.length)return void alert("please provide a valid RGB colour tuple");for(const t of a)if(isNaN(t))return void alert("please provide a valid RGB colour tuple");if(isNaN(r)||r<1)return void alert("please provide fractal level that is an integer number greater than 0");let s;s="Koch"===e?{colour:a,drawType:p.DrawTypes.LINE_LOOP,points:n(r,0)}:{colour:a,drawType:p.DrawTypes.TRIANGLES,points:o(r,0)},s.points.scale(.5),p.addShape(s)},window.addEventListener("keydown",(e=>{const r=p.lastAddedShape;if(r)switch(e.key){case"J":r.points.translate(new t(0,0,-.1));break;case"j":r.points.translate(new t(0,-.1,0));break;case"K":r.points.translate(new t(0,0,.1));break;case"k":r.points.translate(new t(0,.1,0));break;case"h":r.points.translate(new t(-.1,0,0));break;case"l":r.points.translate(new t(.1,0,0))}}))}();
//# sourceMappingURL=index.f5c51071.js.map
