{"mappings":"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","sources":["./types.ts","./ex-5/my-canvas.ts","./ex-5/commands.ts","./ex-5/interpreter.ts","./ex-5/main.ts"],"sourcesContent":["\n/**\n * Simple class that holds two values: `x` and `y`.\n */\nexport class Point2D {\n\n    constructor(\n        public x: number,\n        public y: number\n    ) { }\n\n}\n\nexport class Point3D extends Point2D {\n\n    constructor(\n        public x: number,\n        public y: number,\n        public z: number\n    ) {\n        super(x, y)\n    }\n\n}\n\nexport class Line3D {\n\n    constructor(\n        public begin: Point3D,\n        public end: Point3D\n    ) { }\n\n}\n\nexport class Cuboid {\n\n    private _lines: Line3D[]\n    private _vertices: Point3D[]\n\n    private middle: Point3D\n\n    private maxPoints: Point3D[]\n\n    constructor(\n        x: number,\n        y: number,\n        z: number,\n        width: number,\n        height: number,\n        depth: number\n    ) {\n        this.middle = new Point3D(x, y, z)\n        // prepare all the cuboid vertices\n        const v = [\n            new Point3D(x - width / 2, y - height / 2, z - depth / 2),\n            new Point3D(x - width / 2, y + height / 2, z - depth / 2),\n            new Point3D(x + width / 2, y + height / 2, z - depth / 2),\n            new Point3D(x + width / 2, y - height / 2, z - depth / 2),\n            new Point3D(x - width / 2, y - height / 2, z + depth / 2),\n            new Point3D(x - width / 2, y + height / 2, z + depth / 2),\n            new Point3D(x + width / 2, y + height / 2, z + depth / 2),\n            new Point3D(x + width / 2, y - height / 2, z + depth / 2),\n        ]\n        this._lines = [\n            // “lower” rectangle\n            new Line3D(v[0], v[1]),\n            new Line3D(v[1], v[2]),\n            new Line3D(v[2], v[3]),\n            new Line3D(v[3], v[0]),\n            // “connecting” lines between the “lower” and “upper” rectangles\n            new Line3D(v[0], v[4]),\n            new Line3D(v[1], v[5]),\n            new Line3D(v[2], v[6]),\n            new Line3D(v[3], v[7]),\n            // “upper” rectangle\n            new Line3D(v[4], v[5]),\n            new Line3D(v[5], v[6]),\n            new Line3D(v[6], v[7]),\n            new Line3D(v[7], v[4])\n        ]\n        this._vertices = v\n        // save the vertices that help in determining if given point is inside the cuboid\n        this.maxPoints = [\n            v[0],\n            v[6]\n        ]\n    }\n\n    public get lines() {\n        return this._lines\n    }\n\n    public get vertices() {\n        return this._vertices\n    }\n\n    public isInside(point: Point3D) {\n        const x = point.x\n        const y = point.y\n        const z = point.z\n        const one = this.maxPoints[0]\n        const two = this.maxPoints[1]\n        if (\n            x >= one.x && x <= two.x\n            && y >= one.y && y <= two.y\n            && z >= one.z && z <= two.z\n        ) {\n            return true\n        }\n        return false\n    }\n\n    public rotateX(radian: number) {\n\n        const cos = Math.cos(radian)\n        const sin = Math.sin(radian)\n\n        this.vertices.forEach((p) => {\n            const y = (p.y - this.middle.y) * cos - (p.z - this.middle.z) * sin\n            const z = (p.y - this.middle.y) * sin + (p.z - this.middle.z) * cos\n\n            p.y = y + this.middle.y\n            p.z = z + this.middle.z\n        })\n    }\n\n    public rotateY(radian: number) {\n\n        const cos = Math.cos(radian)\n        const sin = Math.sin(radian)\n\n        this.vertices.forEach((p) => {\n            const x = (p.z - this.middle.z) * sin - (p.x - this.middle.x) * cos\n            const z = (p.z - this.middle.z) * cos + (p.x - this.middle.x) * sin\n\n            p.x = x + this.middle.x\n            p.z = z + this.middle.z\n        })\n    }\n\n}\n\nexport class Projector {\n\n    public static FocalLength = 100\n\n    public static Project3DInto2D(point: Point3D, width: number, height: number): Point2D {\n        const x = point.x * (Projector.FocalLength / point.z) + 0.5 * width;\n        const y = point.y * (Projector.FocalLength / point.z) + 0.5 * height;\n\n        return new Point2D(x, y)\n    }\n\n}\n\n","import { Point2D, Point3D, Projector } from '../types';\n\nexport class MyCanvas {\n\n    /**\n     * Coordinates of the turtle’s current position.\n     */\n    private _currentPos: Point3D;\n    /**\n     * The angle of the turtle.\n     */\n    private currentOrientationXY: number;\n    private currentOrientationYZ: number;\n\n    private maxX: number;\n    private minX: number;\n    private maxY: number;\n    private minY: number;\n    private rangeX: number;\n    private rangeY: number;\n\n    private context: CanvasRenderingContext2D;\n\n    private points: Point3D[] = [];\n\n    constructor(\n        canvasElement: HTMLCanvasElement\n    ) {\n        this.maxX = canvasElement.width;\n        this.minX = 0;\n        this.maxY = canvasElement.height;\n        this.minY = 0;\n        this.rangeX = this.maxX - this.minX;\n        this.rangeY = this.maxY - this.minY;\n\n        this.context = canvasElement.getContext('2d')!;\n\n        this.reset()\n\n        this.setToPrimaryColour()\n\n        this.context.lineWidth = 5;\n    }\n\n    /**\n     * Set stroke colour to the primary colour.\n     */\n    private setToPrimaryColour() {\n        this.context.strokeStyle = \"#000000\";\n    }\n\n    /**\n     * Set stroke colour to the secondary colour.\n     */\n    private setToSecondaryColour() {\n        this.context.strokeStyle = \"#ff00ff\";\n    }\n\n    public rotateX(degrees: number) {\n\n        const radian = degrees / 180 * Math.PI\n\n        this.currentOrientationYZ += radian\n\n        const cos = Math.cos(radian)\n        const sin = Math.sin(radian)\n\n        const points = [...this.points, this._currentPos]\n\n        const middle = new Point3D(0, 0, 0)\n        points.forEach((p) => {\n            const y = (p.y - middle.y) * cos - (p.z - middle.z) * sin\n            const z = (p.y - middle.y) * sin + (p.z - middle.z) * cos\n\n            p.y = y + middle.y\n            p.z = z + middle.z\n        })\n\n    }\n\n    public rotateY(degrees: number) {\n\n        const radian = degrees / 180 * Math.PI\n\n        this.currentOrientationXY += radian\n\n        const cos = Math.cos(radian)\n        const sin = Math.sin(radian)\n\n        const points = [...this.points, this._currentPos]\n\n        const middle = new Point3D(0, 0, 0)\n        points.forEach((p) => {\n            const x = (p.z - middle.z) * sin - (p.x - middle.x) * cos\n            const z = (p.z - middle.z) * cos + (p.x - middle.x) * sin\n\n            p.x = x + middle.x\n            p.z = z + middle.z\n        })\n    }\n\n\n    public async redraw() {\n\n        const c = this.context;\n\n        c.clearRect(this.minX, this.minY, this.rangeX, this.rangeY)\n\n        // draw all the lines\n        this.setToPrimaryColour()\n        c.moveTo(this.rangeX / 2, this.rangeY / 2)\n        c.beginPath()\n        for (let i = 0; i < this.points.length; i++) {\n            const point = Projector.Project3DInto2D(this.points[i], this.rangeX, this.rangeY)\n            // draw the line\n            c.lineTo(point.x, point.y)\n        }\n        c.stroke()\n        c.closePath()\n\n        console.log(this.points)\n\n        // mark the current position\n        const cur = Projector.Project3DInto2D(this._currentPos, this.rangeX, this.rangeY)\n        c.moveTo(cur.x, cur.y)\n        c.beginPath()\n        c.arc(\n            cur.x, cur.y,\n            10,\n            -.75 * Math.PI - this.currentOrientationXY,\n            -0.25 * Math.PI - this.currentOrientationXY\n        )\n        this.setToSecondaryColour()\n        c.stroke()\n        c.closePath()\n\n    }\n\n    /**\n     * Move by some given value on the canvas.\n     */\n    public move(value: number): void {\n        // calc the new position\n        const x = Math.sin(this.currentOrientationXY) * value\n        this._currentPos.x += x\n        const y = Math.cos(this.currentOrientationXY) * value\n        this._currentPos.y += y\n        const z = Math.sin(this.currentOrientationYZ) * value\n        this._currentPos.z += z\n\n        // the new position\n        const newX = this.currentPos.x\n        const newY = this.currentPos.y\n        const newZ = this.currentPos.z\n\n        // save as a new line\n        this.points.push(\n            new Point3D(newX, newY, newZ),\n        );\n    }\n\n    /**\n     * Alter the current orientation.\n     */\n    public rotateXY(value: number): void {\n        this.currentOrientationXY += value / 180 * Math.PI;\n    }\n\n    public rotateYZ(value: number): void {\n        this.currentOrientationYZ += value / 180 * Math.PI;\n    }\n\n    public get currentPos() {\n        return this._currentPos;\n    }\n\n    public reset() {\n        this._currentPos = new Point3D(\n            0,\n            0,\n            -200\n        )\n\n        this.currentOrientationXY = 0\n        this.currentOrientationYZ = 0\n\n        this.points = []\n        this.points.push(new Point3D(\n            0,\n            0,\n            -200\n        ))\n\n        this.redraw()\n    }\n\n}\n","\nexport enum CommandToken {\n    FORWARD = 'F',\n    BACKWARD = 'B',\n    LEFT = 'L',\n    RIGHT = 'R',\n    UPWARDS = 'U',\n    DOWNWARDS = 'D',\n    REPEAT = 'RE',\n    PROCEDURE_BEGIN = 'BE',\n    BRACKET_OPEN = '[',\n    BRACKET_CLOSE = ']',\n    PROCEDURE_END = 'EN',\n    PROCEDURE_TERMINATE = 'TE',\n    IF = 'IF',\n    CALC = 'CA',\n    EQUALS = '='\n}\n\nexport namespace CommandToken {\n\n    const allValues: string[] = Object.keys(CommandToken).map((key) => CommandToken[key])\n\n    export function isOfType(val: any): val is CommandToken {\n        if (allValues.indexOf(val) !== -1) {\n            return true\n        }\n        return false\n    }\n}\n\nexport enum MathOperator {\n    DIVIDE = '/',\n    SUBTRACT = '-',\n    ADD = '+',\n    MULTIPLY = '*'\n}\n\nexport namespace MathOperator {\n\n    const allValues: string[] = Object.keys(MathOperator).map((key) => MathOperator[key])\n\n    export function isOfType(val: any): val is MathOperator {\n        if (allValues.indexOf(val) !== -1) {\n            return true\n        }\n        return false\n    }\n}\n\nexport type RepeatReturnToken = {\n    /**\n     * How many more times the block needs to be run.\n     */\n    repeat: number,\n    /**\n     * Where does the repeat block begin.\n     */\n    index: number\n}\n\nexport type TokenStackElement = string\n    | CommandToken\n    | RepeatReturnToken\n\nexport class CommandStack {\n\n    public pointer: number = 0\n    public stack: TokenStackElement[]\n\n    constructor(stack?: string);\n    constructor(stack: string) {\n        if (stack) {\n            // split given string of commands because of:\n            // - whitespace,\n            // - two tokens where one is the BRACKET token\n            this.stack = stack.trim().split(/\\s|(?<=\\[)|(?=\\])/)\n        }\n    }\n\n    /**\n     * Alternative constructor that skips the token parsing process.\n     */\n    public static from(stack: TokenStackElement[]): CommandStack {\n        const commandStack = new CommandStack()\n        commandStack.stack = stack\n        return commandStack\n    }\n\n    public static copy(stack: CommandStack): CommandStack {\n        const commandStack = new CommandStack()\n        commandStack.stack = [...stack.stack]\n        return commandStack\n    }\n\n    public get isDone(): boolean {\n        return this.pointer > this.stack.length - 1\n    }\n\n    public get currentElement() {\n        return this.stack[this.pointer]\n    }\n\n    public set currentElement(val: TokenStackElement) {\n        this.stack[this.pointer] = val\n    }\n\n    /**\n     * Get the next item of the stack without removing it.\n     */\n    public pop(): TokenStackElement {\n        return this.stack[this.pointer++]\n    }\n\n    public popUntil(until: TokenStackElement): TokenStackElement[] {\n        const output: TokenStackElement[] = []\n        let i = this.pointer\n        while (i < this.stack.length && this.stack[i] !== until) {\n            output.push(this.stack[i])\n            i++\n        }\n        this.pointer = i\n        return output\n    }\n\n    /**\n     * Pop `count` elements.\n     */\n    public popCount(count: number, hard: boolean = false): TokenStackElement[] {\n        let output: TokenStackElement[]\n        if (hard) {\n            output = this.stack.splice(this.pointer, count)\n        } else {\n            output = this.stack.slice(this.pointer, this.pointer + count)\n            this.pointer += count\n        }\n        return output\n    }\n\n    public putBack(elements: TokenStackElement[]) {\n        this.stack.splice(this.pointer, 0, ...elements)\n    }\n\n    public insert(element: TokenStackElement, index: number = this.pointer) {\n        this.stack.splice(index, 0, element)\n    }\n\n    public removePrevious() {\n        this.stack.splice(this.pointer - 1, 1)\n    }\n\n    public terminate() {\n        this.pointer = this.stack.length\n    }\n\n    public reset() {\n        this.pointer = 0\n    }\n\n}\n\nexport class LogoProcedure {\n\n    constructor(\n        private _stack: CommandStack,\n        private _args: string[]\n    ) { }\n\n    public get stack() {\n        return this._stack\n    }\n\n    public get args() {\n        return this._args\n    }\n\n    public get argCount() {\n        return this._args.length\n    }\n\n}\n","import { MyCanvas } from './my-canvas'\nimport { CommandStack, CommandToken, LogoProcedure, MathOperator, RepeatReturnToken, TokenStackElement } from './commands'\n\n// shorthand for parsing decimal numbers\nconst parseDecimal = (val: string) => parseInt(val, 10)\n\n/**\n * The Logo command interpreter.\n */\nexport class LogoInterpreter {\n\n    private tokenStack: CommandStack\n\n    private procedures: {\n        [key: string]: LogoProcedure\n    } = {}\n\n    constructor(\n        private myCanvas: MyCanvas\n    ) { }\n\n    private handleAtomicAction(action: CommandToken, rawValue: string) {\n        const value = parseDecimal(rawValue)\n        switch (action) {\n            case CommandToken.FORWARD:\n                this.myCanvas.move(value)\n                break\n            case CommandToken.BACKWARD:\n                this.myCanvas.move(-1 * value)\n                break\n            case CommandToken.LEFT:\n                this.myCanvas.rotateXY(value)\n                break\n            case CommandToken.RIGHT:\n                this.myCanvas.rotateXY(-1 * value)\n                break\n            case CommandToken.UPWARDS:\n                this.myCanvas.rotateYZ(value)\n                break\n            case CommandToken.DOWNWARDS:\n                this.myCanvas.rotateYZ(-1 * value)\n                break\n        }\n\n    }\n\n    public async ExecuteCommandStack(stack: string) {\n        this.tokenStack = new CommandStack(stack)\n\n        this.preComputeMathExpressions(this.tokenStack)\n\n        while (!this.tokenStack.isDone) {\n            await this.handleCommand()\n        }\n\n    }\n\n    private findEndingBracket(openingBracketIndex: number, stack: CommandStack): number {\n        let innerLoops = 0\n        const s = stack.stack\n        for (let i = openingBracketIndex + 1; i < s.length; i++) {\n            if (s[i] === CommandToken.BRACKET_OPEN) {\n                innerLoops++\n            }\n            else if (s[i] === CommandToken.BRACKET_CLOSE) {\n                if (innerLoops == 0) {\n                    // replace the ending bracket with a return packet\n                    return i\n                }\n                else innerLoops--\n            }\n        }\n    }\n\n    /**\n     * Compute the condition based on given operator token.\n     */\n    private computeCondition(elements: TokenStackElement[]): boolean {\n        const left = elements[0]\n        const operator = elements[1] as CommandToken\n        const right = elements[2]\n        switch (operator) {\n            case CommandToken.EQUALS:\n                if (left === right) {\n                    return true\n                } else {\n                    return false\n                }\n        }\n\n        return false\n    }\n\n    private computeExpression(elements: TokenStackElement[]): number {\n        const left = parseDecimal(elements[0] as string)\n        const operator = elements[1] as MathOperator\n        const right = parseDecimal(elements[2] as string)\n        switch (operator) {\n            case MathOperator.DIVIDE:\n                return left / right\n            case MathOperator.ADD:\n                return left + right\n            case MathOperator.MULTIPLY:\n                return left * right\n            case MathOperator.SUBTRACT:\n                return left - right\n        }\n    }\n\n    private preComputeMathExpressions(stack: CommandStack) {\n\n        while (!stack.isDone) {\n            const e = stack.pop()\n            if (e === CommandToken.CALC) {\n                // we need three arguments\n                // remove them, so they can be replaced by the expression result\n                const elements = stack.popCount(3, true)\n                // compute\n                const result = this.computeExpression(elements)\n                if (isNaN(result)) {\n                    // the expression contained a variable that wasn’t replaced by its value yet\n                    // we need to put back the original expression elements\n                    stack.putBack(elements)\n                } else {\n                    // insert the result back into place of the expression\n                    stack.insert(String(result))\n                    // remove the CALC token\n                    stack.removePrevious()\n                }\n            }\n        }\n\n        stack.reset()\n    }\n\n    /**\n     * Handle given command.\n     */\n    private async handleCommand(stack = this.tokenStack) {\n\n        // take the top token\n        const actionToken = stack.pop()\n\n        if (!actionToken) return\n\n        if (CommandToken.isOfType(actionToken)) {\n            // handle the token\n            switch (actionToken) {\n                case CommandToken.BACKWARD:\n                case CommandToken.FORWARD:\n                case CommandToken.LEFT:\n                case CommandToken.RIGHT:\n                case CommandToken.UPWARDS:\n                case CommandToken.DOWNWARDS:\n                    // expecting an action that takes exactly one argument\n                    const value = stack.pop()\n                    if (typeof value === 'string')\n                        this.handleAtomicAction(actionToken, value)\n                    break\n                case CommandToken.REPEAT:\n                    // how many times does the routine run\n                    const timesRaw = stack.pop()\n                    if (typeof timesRaw === 'string') {\n                        const repeat = parseDecimal(timesRaw) - 1\n                        // get the index of the next command\n                        // that will be the first operation of the REPEAT clause\n                        const index = stack.pointer\n                        // place the return packet in place of the ending bracket\n                        stack.stack[this.findEndingBracket(index, stack)] = {\n                            index,\n                            repeat\n                        }\n                    }\n                    break\n                case CommandToken.IF: {\n                    // every token that is between IF and BRACKET_OPEN is the condition\n                    const conditionElements = stack.popUntil(CommandToken.BRACKET_OPEN)\n                    // we’re expecting three elements\n                    const result = this.computeCondition(conditionElements)\n                    if (result) {\n                        // the condition is met, remove the opening bracket\n                        stack.pop()\n                    } else {\n                        // otherwise skip the whole block\n                        stack.popUntil(CommandToken.BRACKET_CLOSE)\n                        // remove the closing bracket just in case\n                        stack.pop()\n                    }\n                    break\n                }\n                case CommandToken.PROCEDURE_BEGIN: {\n                    // get the name of the procedure\n                    const name = stack.pop() as string\n                    // get the count of the arguments\n                    const argCount = parseDecimal(stack.pop() as string)\n                    // get the arguments of the procedure\n                    const args = stack.popCount(argCount) as string[]\n                    // get all the commands of the procedure\n                    const procedureInnerStack = stack.popUntil(CommandToken.PROCEDURE_END)\n                    const procedure = new LogoProcedure(\n                        CommandStack.from(procedureInnerStack),\n                        args\n                    )\n                    // save the procedure\n                    this.procedures[name] = procedure\n                    break\n                }\n                case CommandToken.PROCEDURE_TERMINATE: {\n                    // terminate the current stack\n                    stack.terminate()\n                    break\n                }\n            }\n        } else if (Object.keys(this.procedures).includes(actionToken as string)) {\n            // procedure\n\n            const procedure = this.procedures[actionToken as string]\n            // get args\n            const argValues = stack.popCount(procedure.argCount) as string[]\n\n            // copy the stack\n            const innerStack = CommandStack.copy(procedure.stack)\n\n            // replace arg names with values\n            let i = 0\n            innerStack.stack.forEach((element) => {\n                if (procedure.args.includes(element as string)) {\n                    const index = procedure.args.indexOf(element as string)\n                    innerStack.stack[i] = argValues[index]\n                }\n                i++\n            })\n\n            this.preComputeMathExpressions(innerStack)\n\n            // run the procedure\n            while (!innerStack.isDone) {\n                await this.handleCommand(innerStack)\n            }\n\n        } else if (typeof actionToken !== 'string') {\n            // repeat return token\n\n            if (actionToken.repeat > 0) {\n                stack.pointer = actionToken.index\n                actionToken.repeat--\n            } else {\n                stack.pointer--\n                stack.currentElement = CommandToken.BRACKET_CLOSE\n                stack.pointer++\n            }\n\n        }\n    }\n\n}\n","import { MyCanvas } from \"./my-canvas\";\nimport { LogoInterpreter } from './interpreter';\n\n// get all the necessary elements\nconst form = document.getElementById('execution-form')\nconst input = document.getElementById('command-input') as HTMLInputElement\nconst canvas = document.getElementById('canvas') as HTMLCanvasElement\nconst clearButton = document.getElementById('clear-button') as HTMLButtonElement\n\nconst exampleButtons = document.getElementsByClassName('example-button') as HTMLCollectionOf<HTMLButtonElement>\n\nif (form !== null && input !== null && canvas !== null && clearButton !== null) {\n\n    let myCanvas: MyCanvas = new MyCanvas(canvas)\n\n    myCanvas.redraw()\n\n    document.addEventListener('keydown', (event: KeyboardEvent) => {\n\n        switch(event.key) {\n            case 'ArrowUp':\n                myCanvas.rotateX(5)\n                break\n            case 'ArrowDown':\n                myCanvas.rotateX(-5)\n                break\n            case 'ArrowLeft':\n                myCanvas.rotateY(-5)\n                break\n            case 'ArrowRight':\n                myCanvas.rotateY(5)\n                break\n        }\n\n        myCanvas.redraw()\n\n    })\n\n    form.onsubmit = (event: Event) => {\n\n        // prevent refreshing the page\n        event.preventDefault()\n\n        setTimeout(async () => {\n\n            // get the value\n            const tokens = input.value\n\n            const interpreter = new LogoInterpreter(myCanvas)\n\n            await interpreter.ExecuteCommandStack(tokens)\n\n            await myCanvas.redraw()\n\n        }, 50)\n    }\n\n    clearButton.onclick = (event: Event) => {\n\n        event.preventDefault()\n\n        myCanvas.reset()\n\n    }\n\n    const examples = [\n        `\nF 10\nR 90\nF 10\nR 90\nF 10\nR 90\nF 10\n        `,\n        `\nRE 5 [F 100 R 72]\n        `,\n        `\nRE 9 [F 100 R 40]\n        `,\n        `\nBE koch 2 :st :a\n    IF :st = 0 [ F :a TE ]\n    koch CA :st - 1 CA :a / 3 R 60\n    koch CA :st - 1 CA :a / 3 L 120\n    koch CA :st - 1 CA :a / 3 R 60\n    koch CA :st - 1 CA :a / 3\nEN\n\n\nBE star 2 :st :a\n    RE 3 [ koch :st :a L 120]\nEN\n\nstar 5 300\n        `,\n        `\nBE troj 1 :a\n    RE 3 [F :a R 120]\nEN\n\nBE sierp 2 :n :a\n    IF :n = 0 [troj :a TE]\n    troj :a\n\n    sierp CA :n - 1 CA :a / 2\n    F CA :a / 2\n    sierp CA :n - 1 CA :a / 2\n    R 60\n    F CA :a / 2 R 60\n\n    sierp CA :n - 1 CA :a / 2\n    L 60 B CA :a / 2\n    L 60 B CA :a / 2\nEN\n\nBE sierpinski 2 :n :a\n    R 30\n    sierp :n :a\nEN\n\nsierpinski 5 300\n\n        `\n    ]\n\n    for (let i = 0; i < exampleButtons.length; i++) {\n        const button = exampleButtons[i]\n        const example = examples[i]\n\n        button.onclick = (event: Event) => {\n            input.value = example\n        }\n    }\n\n}\n"],"names":["$4637b441e76e2d234d42edafff295e88$export$Point2D","constructor","x","y","$4637b441e76e2d234d42edafff295e88$export$Point3D","z","super","$4637b441e76e2d234d42edafff295e88$export$Projector","point","width","height","FocalLength","$6e7dbd7edf3be93e8b2e49b50584a162$export$MyCanvas","points","canvasElement","this","maxX","minX","maxY","minY","rangeX","rangeY","context","getContext","reset","setToPrimaryColour","lineWidth","strokeStyle","setToSecondaryColour","rotateX","degrees","radian","Math","PI","currentOrientationYZ","cos","sin","_currentPos","middle","forEach","p","rotateY","currentOrientationXY","c","clearRect","moveTo","beginPath","i","length","Project3DInto2D","lineTo","stroke","closePath","console","log","cur","arc","move","value","newX","currentPos","newY","newZ","push","rotateXY","rotateYZ","redraw","$1670480fe5679b5e4efef20f8099bf23$export$CommandToken","CommandToken","$1670480fe5679b5e4efef20f8099bf23$export$MathOperator","MathOperator","allValues","Object","keys","map","key","val","indexOf","$1670480fe5679b5e4efef20f8099bf23$export$CommandStack","pointer","stack","trim","split","commandStack","pop","popUntil","until","output","popCount","count","hard","splice","slice","putBack","elements","insert","element","index","removePrevious","terminate","$1670480fe5679b5e4efef20f8099bf23$export$LogoProcedure","_stack","_args","$b3380ac7e5c0a174529c1cc8af2c84b8$var$parseDecimal","parseInt","$b3380ac7e5c0a174529c1cc8af2c84b8$export$LogoInterpreter","procedures","myCanvas","handleAtomicAction","action","rawValue","FORWARD","BACKWARD","LEFT","RIGHT","UPWARDS","DOWNWARDS","tokenStack","preComputeMathExpressions","isDone","handleCommand","findEndingBracket","openingBracketIndex","innerLoops","s","BRACKET_OPEN","BRACKET_CLOSE","computeCondition","left","operator","right","EQUALS","computeExpression","DIVIDE","ADD","MULTIPLY","SUBTRACT","e","CALC","result","isNaN","String","actionToken","isOfType","REPEAT","timesRaw","repeat","IF","conditionElements","PROCEDURE_BEGIN","name","argCount","args","procedureInnerStack","PROCEDURE_END","procedure","from","PROCEDURE_TERMINATE","includes","argValues","innerStack","copy","currentElement","$cd85d996c5d2dfb1a3cd99c4ab535ecd$var$form","document","getElementById","$cd85d996c5d2dfb1a3cd99c4ab535ecd$var$input","$cd85d996c5d2dfb1a3cd99c4ab535ecd$var$canvas","$cd85d996c5d2dfb1a3cd99c4ab535ecd$var$clearButton","$cd85d996c5d2dfb1a3cd99c4ab535ecd$var$exampleButtons","getElementsByClassName","addEventListener","event","onsubmit","preventDefault","setTimeout","async","tokens","interpreter","ExecuteCommandStack","onclick","examples","button","example"],"version":3,"file":"index.4415f298.js.map"}