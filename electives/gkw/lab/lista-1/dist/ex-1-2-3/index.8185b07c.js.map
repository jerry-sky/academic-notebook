{"mappings":"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","sources":["./types.ts","./ex-1-2-3/my-canvas.ts","./ex-1-2-3/commands.ts","./ex-1-2-3/interpreter.ts","./ex-1-2-3/svg-canvas.ts","./ex-1-2-3/main.ts"],"sourcesContent":["\n/**\n * Simple class that holds two values: `x` and `y`.\n */\nexport class Point2D {\n\n    constructor(\n        public x: number,\n        public y: number\n    ) { }\n\n}\n\nexport class Point3D extends Point2D {\n\n    constructor(\n        public x: number,\n        public y: number,\n        public z: number\n    ) {\n        super(x, y)\n    }\n\n}\n\nexport class Line3D {\n\n    constructor(\n        public begin: Point3D,\n        public end: Point3D\n    ) { }\n\n}\n\nexport class Cuboid {\n\n    private _lines: Line3D[]\n    private _vertices: Point3D[]\n\n    private middle: Point3D\n\n    private maxPoints: Point3D[]\n\n    constructor(\n        x: number,\n        y: number,\n        z: number,\n        width: number,\n        height: number,\n        depth: number\n    ) {\n        this.middle = new Point3D(x, y, z)\n        // prepare all the cuboid vertices\n        const v = [\n            new Point3D(x - width / 2, y - height / 2, z - depth / 2),\n            new Point3D(x - width / 2, y + height / 2, z - depth / 2),\n            new Point3D(x + width / 2, y + height / 2, z - depth / 2),\n            new Point3D(x + width / 2, y - height / 2, z - depth / 2),\n            new Point3D(x - width / 2, y - height / 2, z + depth / 2),\n            new Point3D(x - width / 2, y + height / 2, z + depth / 2),\n            new Point3D(x + width / 2, y + height / 2, z + depth / 2),\n            new Point3D(x + width / 2, y - height / 2, z + depth / 2),\n        ]\n        this._lines = [\n            // “lower” rectangle\n            new Line3D(v[0], v[1]),\n            new Line3D(v[1], v[2]),\n            new Line3D(v[2], v[3]),\n            new Line3D(v[3], v[0]),\n            // “connecting” lines between the “lower” and “upper” rectangles\n            new Line3D(v[0], v[4]),\n            new Line3D(v[1], v[5]),\n            new Line3D(v[2], v[6]),\n            new Line3D(v[3], v[7]),\n            // “upper” rectangle\n            new Line3D(v[4], v[5]),\n            new Line3D(v[5], v[6]),\n            new Line3D(v[6], v[7]),\n            new Line3D(v[7], v[4])\n        ]\n        this._vertices = v\n        // save the vertices that help in determining if given point is inside the cuboid\n        this.maxPoints = [\n            v[0],\n            v[6]\n        ]\n    }\n\n    public get lines() {\n        return this._lines\n    }\n\n    public get vertices() {\n        return this._vertices\n    }\n\n    public isInside(point: Point3D) {\n        const x = point.x\n        const y = point.y\n        const z = point.z\n        const one = this.maxPoints[0]\n        const two = this.maxPoints[1]\n        if (\n            x >= one.x && x <= two.x\n            && y >= one.y && y <= two.y\n            && z >= one.z && z <= two.z\n        ) {\n            return true\n        }\n        return false\n    }\n\n    public rotateX(radian: number) {\n\n        const cos = Math.cos(radian)\n        const sin = Math.sin(radian)\n\n        this.vertices.forEach((p) => {\n            const y = (p.y - this.middle.y) * cos - (p.z - this.middle.z) * sin\n            const z = (p.y - this.middle.y) * sin + (p.z - this.middle.z) * cos\n\n            p.y = y + this.middle.y\n            p.z = z + this.middle.z\n        })\n    }\n\n    public rotateY(radian: number) {\n\n        const cos = Math.cos(radian)\n        const sin = Math.sin(radian)\n\n        this.vertices.forEach((p) => {\n            const x = (p.z - this.middle.z) * sin - (p.x - this.middle.x) * cos\n            const z = (p.z - this.middle.z) * cos + (p.x - this.middle.x) * sin\n\n            p.x = x + this.middle.x\n            p.z = z + this.middle.z\n        })\n    }\n\n}\n\nexport class Projector {\n\n    public static FocalLength = 100\n\n    public static Project3DInto2D(point: Point3D, width: number, height: number): Point2D {\n        const x = point.x * (Projector.FocalLength / point.z) + 0.5 * width;\n        const y = point.y * (Projector.FocalLength / point.z) + 0.5 * height;\n\n        return new Point2D(x, y)\n    }\n\n}\n\n","import { Point2D } from '../types';\nimport { CanvasRenderer } from './canvas-renderer'\n\nexport class MyCanvas implements CanvasRenderer {\n\n    /**\n     * Coordinates of the turtle’s current position.\n     */\n    private _currentPos: Point2D;\n    /**\n     * The angle of the turtle.\n     */\n    private _currentOrientation: number;\n\n    private maxX: number;\n    private minX: number;\n    private maxY: number;\n    private minY: number;\n    private rangeX: number;\n    private rangeY: number;\n\n    private context: CanvasRenderingContext2D;\n\n    private points: Point2D[] = [];\n\n    constructor(\n        canvasElement: HTMLCanvasElement\n    ) {\n        this.maxX = canvasElement.width;\n        this.minX = 0;\n        this.maxY = canvasElement.height;\n        this.minY = 0;\n        this.rangeX = this.maxX - this.minX;\n        this.rangeY = this.maxY - this.minY;\n\n        this._currentPos = new Point2D(this.rangeX / 2, this.rangeY / 2);\n        this._currentOrientation = 0;\n        this.points.push(new Point2D(this.rangeX / 2, this.rangeY / 2))\n\n        this.context = canvasElement.getContext('2d')!;\n\n        this.context.lineWidth = 5;\n        this.context.strokeStyle = \"#000000\";\n    }\n\n    /**\n     * Set stroke colour to the primary colour.\n     */\n    private setToPrimaryColour() {\n        this.context.strokeStyle = \"#000000\";\n    }\n\n    /**\n     * Set stroke colour to the secondary colour.\n     */\n    private setToSecondaryColour() {\n        this.context.strokeStyle = \"#ff00ff\";\n    }\n\n    public async redraw() {\n\n        const c = this.context;\n\n        c.clearRect(this.minX, this.minY, this.rangeX, this.rangeY);\n\n        // draw all the lines\n        this.setToPrimaryColour();\n        c.moveTo(this.rangeX / 2, this.rangeY / 2)\n        c.beginPath();\n        for (let i = 0; i < this.points.length; i++) {\n            const point = this.points[i]\n            // draw the line\n            c.lineTo(point.x, point.y);\n        }\n        c.stroke();\n        c.closePath();\n\n        // mark the current position\n        const cur = this._currentPos;\n        c.moveTo(cur.x, cur.y);\n        c.beginPath();\n        c.arc(\n            cur.x, cur.y,\n            10,\n            -.75 * Math.PI - this._currentOrientation,\n            -0.25 * Math.PI - this._currentOrientation\n        );\n        this.setToSecondaryColour();\n        c.stroke();\n        c.closePath();\n\n    }\n\n    /**\n     * Move by some given value on the canvas.\n     */\n    public move(value: number): void {\n        // calc the new position\n        const x = Math.sin(this._currentOrientation) * value;\n        this._currentPos.x += x;\n        const y = Math.cos(this._currentOrientation) * value;\n        this._currentPos.y += y;\n\n        // the new position\n        const newX = this.currentPos.x;\n        const newY = this.currentPos.y;\n\n        // save as a new line\n        this.points.push(\n            new Point2D(newX, newY),\n        );\n    }\n\n    /**\n     * Alter the current orientation.\n     */\n    public rotate(value: number): void {\n        this._currentOrientation += value / 180 * Math.PI;\n    }\n\n    public get currentPos() {\n        return this._currentPos;\n    }\n\n    public reset() {\n        this._currentPos = new Point2D(this.rangeX / 2, this.rangeY / 2)\n        this._currentOrientation = 0\n        this.context.clearRect(this.minX, this.minY, this.rangeX, this.rangeY);\n        this.points = []\n        this.points.push(new Point2D(this.rangeX / 2, this.rangeY / 2))\n        this.redraw()\n    }\n\n}\n","\nexport enum CommandToken {\n    FORWARD = 'F',\n    BACKWARD = 'B',\n    LEFT = 'L',\n    RIGHT = 'R',\n    REPEAT = 'RE',\n    PROCEDURE_BEGIN = 'BE',\n    BRACKET_OPEN = '[',\n    BRACKET_CLOSE = ']',\n    PROCEDURE_END = 'EN',\n    PROCEDURE_TERMINATE = 'TE',\n    IF = 'IF',\n    CALC = 'CA',\n    EQUALS = '='\n}\n\nexport namespace CommandToken {\n\n    const allValues: string[] = Object.keys(CommandToken).map((key) => CommandToken[key])\n\n    export function isOfType(val: any): val is CommandToken {\n        if (allValues.indexOf(val) !== -1) {\n            return true\n        }\n        return false\n    }\n}\n\nexport enum MathOperator {\n    DIVIDE = '/',\n    SUBTRACT = '-',\n    ADD = '+',\n    MULTIPLY = '*'\n}\n\nexport namespace MathOperator {\n\n    const allValues: string[] = Object.keys(MathOperator).map((key) => MathOperator[key])\n\n    export function isOfType(val: any): val is MathOperator {\n        if (allValues.indexOf(val) !== -1) {\n            return true\n        }\n        return false\n    }\n}\n\nexport type RepeatReturnToken = {\n    /**\n     * How many more times the block needs to be run.\n     */\n    repeat: number,\n    /**\n     * Where does the repeat block begin.\n     */\n    index: number\n}\n\nexport type TokenStackElement = string\n    | CommandToken\n    | RepeatReturnToken\n\nexport class CommandStack {\n\n    public pointer: number = 0\n    public stack: TokenStackElement[]\n\n    constructor(stack?: string);\n    constructor(stack: string) {\n        if (stack) {\n            // split given string of commands because of:\n            // - whitespace,\n            // - two tokens where one is the BRACKET token\n            this.stack = stack.trim().split(/\\s|(?<=\\[)|(?=\\])/)\n        }\n    }\n\n    /**\n     * Alternative constructor that skips the token parsing process.\n     */\n    public static from(stack: TokenStackElement[]): CommandStack {\n        const commandStack = new CommandStack()\n        commandStack.stack = stack\n        return commandStack\n    }\n\n    public static copy(stack: CommandStack): CommandStack {\n        const commandStack = new CommandStack()\n        commandStack.stack = [...stack.stack]\n        return commandStack\n    }\n\n    public get isDone(): boolean {\n        return this.pointer > this.stack.length - 1\n    }\n\n    public get currentElement() {\n        return this.stack[this.pointer]\n    }\n\n    public set currentElement(val: TokenStackElement) {\n        this.stack[this.pointer] = val\n    }\n\n    /**\n     * Get the next item of the stack without removing it.\n     */\n    public pop(): TokenStackElement {\n        return this.stack[this.pointer++]\n    }\n\n    public popUntil(until: TokenStackElement): TokenStackElement[] {\n        const output: TokenStackElement[] = []\n        let i = this.pointer\n        while (i < this.stack.length && this.stack[i] !== until) {\n            output.push(this.stack[i])\n            i++\n        }\n        this.pointer = i\n        return output\n    }\n\n    /**\n     * Pop `count` elements.\n     */\n    public popCount(count: number, hard: boolean = false): TokenStackElement[] {\n        let output: TokenStackElement[]\n        if (hard) {\n            output = this.stack.splice(this.pointer, count)\n        } else {\n            output = this.stack.slice(this.pointer, this.pointer + count)\n            this.pointer += count\n        }\n        return output\n    }\n\n    public putBack(elements: TokenStackElement[]) {\n        this.stack.splice(this.pointer, 0, ...elements)\n    }\n\n    public insert(element: TokenStackElement, index: number = this.pointer) {\n        this.stack.splice(index, 0, element)\n    }\n\n    public removePrevious() {\n        this.stack.splice(this.pointer - 1, 1)\n    }\n\n    public terminate() {\n        this.pointer = this.stack.length\n    }\n\n    public reset() {\n        this.pointer = 0\n    }\n\n}\n\nexport class LogoProcedure {\n\n    constructor(\n        private _stack: CommandStack,\n        private _args: string[]\n    ) { }\n\n    public get stack() {\n        return this._stack\n    }\n\n    public get args() {\n        return this._args\n    }\n\n    public get argCount() {\n        return this._args.length\n    }\n\n}\n","import { MyCanvas } from './my-canvas'\nimport { CommandStack, CommandToken, LogoProcedure, MathOperator, RepeatReturnToken, TokenStackElement } from './commands'\nimport { CanvasRenderer } from './canvas-renderer'\n\n// shorthand for parsing decimal numbers\nconst parseDecimal = (val: string) => parseInt(val, 10)\n\n/**\n * The Logo command interpreter.\n */\nexport class LogoInterpreter {\n\n    private tokenStack: CommandStack\n\n    private procedures: {\n        [key: string]: LogoProcedure\n    } = {}\n\n    constructor(\n        private myCanvas: CanvasRenderer\n    ) { }\n\n    private handleAtomicAction(action: CommandToken, rawValue: string) {\n        const value = parseDecimal(rawValue)\n        switch (action) {\n            case CommandToken.FORWARD:\n                this.myCanvas.move(-1 * value)\n                break\n            case CommandToken.BACKWARD:\n                this.myCanvas.move(value)\n                break\n            case CommandToken.LEFT:\n                this.myCanvas.rotate(value)\n                break\n            case CommandToken.RIGHT:\n                this.myCanvas.rotate(-1 * value)\n                break\n        }\n\n    }\n\n    public async ExecuteCommandStack(stack: string) {\n        this.tokenStack = new CommandStack(stack)\n\n        this.preComputeMathExpressions(this.tokenStack)\n\n        while (!this.tokenStack.isDone) {\n            await this.handleCommand()\n        }\n\n    }\n\n    private findEndingBracket(openingBracketIndex: number, stack: CommandStack): number {\n        let innerLoops = 0\n        const s = stack.stack\n        for (let i = openingBracketIndex + 1; i < s.length; i++) {\n            if (s[i] === CommandToken.BRACKET_OPEN) {\n                innerLoops++\n            }\n            else if (s[i] === CommandToken.BRACKET_CLOSE) {\n                if (innerLoops == 0) {\n                    // replace the ending bracket with a return packet\n                    return i\n                }\n                else innerLoops--\n            }\n        }\n    }\n\n    /**\n     * Compute the condition based on given operator token.\n     */\n    private computeCondition(elements: TokenStackElement[]): boolean {\n        const left = elements[0]\n        const operator = elements[1] as CommandToken\n        const right = elements[2]\n        switch (operator) {\n            case CommandToken.EQUALS:\n                if (left === right) {\n                    return true\n                } else {\n                    return false\n                }\n        }\n\n        return false\n    }\n\n    private computeExpression(elements: TokenStackElement[]): number {\n        const left = parseDecimal(elements[0] as string)\n        const operator = elements[1] as MathOperator\n        const right = parseDecimal(elements[2] as string)\n        switch (operator) {\n            case MathOperator.DIVIDE:\n                return left / right\n            case MathOperator.ADD:\n                return left + right\n            case MathOperator.MULTIPLY:\n                return left * right\n            case MathOperator.SUBTRACT:\n                return left - right\n        }\n    }\n\n    private preComputeMathExpressions(stack: CommandStack) {\n\n        while (!stack.isDone) {\n            const e = stack.pop()\n            if (e === CommandToken.CALC) {\n                // we need three arguments\n                // remove them, so they can be replaced by the expression result\n                const elements = stack.popCount(3, true)\n                // compute\n                const result = this.computeExpression(elements)\n                if (isNaN(result)) {\n                    // the expression contained a variable that wasn’t replaced by its value yet\n                    // we need to put back the original expression elements\n                    stack.putBack(elements)\n                } else {\n                    // insert the result back into place of the expression\n                    stack.insert(String(result))\n                    // remove the CALC token\n                    stack.removePrevious()\n                }\n            }\n        }\n\n        stack.reset()\n    }\n\n    /**\n     * Handle given command.\n     */\n    private async handleCommand(stack = this.tokenStack) {\n\n        // take the top token\n        const actionToken = stack.pop()\n\n        if (!actionToken) return\n\n        if (CommandToken.isOfType(actionToken)) {\n            // handle the token\n            switch (actionToken) {\n                case CommandToken.BACKWARD:\n                case CommandToken.FORWARD:\n                case CommandToken.LEFT:\n                case CommandToken.RIGHT:\n                    // expecting an action that takes exactly one argument\n                    const value = stack.pop()\n                    if (typeof value === 'string')\n                        this.handleAtomicAction(actionToken, value)\n                    break\n                case CommandToken.REPEAT:\n                    // how many times does the routine run\n                    const timesRaw = stack.pop()\n                    if (typeof timesRaw === 'string') {\n                        const repeat = parseDecimal(timesRaw) - 1\n                        // get the index of the next command\n                        // that will be the first operation of the REPEAT clause\n                        const index = stack.pointer\n                        // place the return packet in place of the ending bracket\n                        stack.stack[this.findEndingBracket(index, stack)] = {\n                            index,\n                            repeat\n                        }\n                    }\n                    break\n                case CommandToken.IF: {\n                    // every token that is between IF and BRACKET_OPEN is the condition\n                    const conditionElements = stack.popUntil(CommandToken.BRACKET_OPEN)\n                    // we’re expecting three elements\n                    const result = this.computeCondition(conditionElements)\n                    if (result) {\n                        // the condition is met, remove the opening bracket\n                        stack.pop()\n                    } else {\n                        // otherwise skip the whole block\n                        stack.popUntil(CommandToken.BRACKET_CLOSE)\n                        // remove the closing bracket just in case\n                        stack.pop()\n                    }\n                    break\n                }\n                case CommandToken.PROCEDURE_BEGIN: {\n                    // get the name of the procedure\n                    const name = stack.pop() as string\n                    // get the count of the arguments\n                    const argCount = parseDecimal(stack.pop() as string)\n                    // get the arguments of the procedure\n                    const args = stack.popCount(argCount) as string[]\n                    // get all the commands of the procedure\n                    const procedureInnerStack = stack.popUntil(CommandToken.PROCEDURE_END)\n                    const procedure = new LogoProcedure(\n                        CommandStack.from(procedureInnerStack),\n                        args\n                    )\n                    // save the procedure\n                    this.procedures[name] = procedure\n                    break\n                }\n                case CommandToken.PROCEDURE_TERMINATE: {\n                    // terminate the current stack\n                    stack.terminate()\n                    break\n                }\n            }\n        } else if (Object.keys(this.procedures).includes(actionToken as string)) {\n            // procedure\n\n            const procedure = this.procedures[actionToken as string]\n            // get args\n            const argValues = stack.popCount(procedure.argCount) as string[]\n\n            // copy the stack\n            const innerStack = CommandStack.copy(procedure.stack)\n\n            // replace arg names with values\n            let i = 0\n            innerStack.stack.forEach((element) => {\n                if (procedure.args.includes(element as string)) {\n                    const index = procedure.args.indexOf(element as string)\n                    innerStack.stack[i] = argValues[index]\n                }\n                i++\n            })\n\n            this.preComputeMathExpressions(innerStack)\n\n            // run the procedure\n            while (!innerStack.isDone) {\n                await this.handleCommand(innerStack)\n            }\n\n        } else if (typeof actionToken !== 'string') {\n            // repeat return token\n\n            if (actionToken.repeat > 0) {\n                stack.pointer = actionToken.index\n                actionToken.repeat--\n            } else {\n                stack.pointer--\n                stack.currentElement = CommandToken.BRACKET_CLOSE\n                stack.pointer++\n            }\n\n        }\n    }\n\n}\n","import { Point2D } from '../types';\nimport { CanvasRenderer } from './canvas-renderer';\n\nexport class SVGCanvas implements CanvasRenderer {\n\n    /**\n     * Coordinates of the turtle’s current position.\n     */\n    private _currentPos: Point2D;\n    /**\n     * The angle of the turtle.\n     */\n    private _currentOrientation: number;\n\n    private maxX: number;\n    private minX: number;\n    private maxY: number;\n    private minY: number;\n    private rangeX: number;\n    private rangeY: number;\n\n    private points: Point2D[] = []\n\n    constructor(\n        private svgCanvas: SVGElement\n    ) {\n        this.minX = 0\n        this.minY = 0\n        this.maxX = this.svgCanvas.clientWidth\n        this.maxY = this.svgCanvas.clientHeight\n        this.rangeX = this.maxX - this.minX;\n        this.rangeY = this.maxY - this.minY;\n\n        this._currentPos = new Point2D(this.rangeX / 2, this.rangeY / 2);\n        this._currentOrientation = 0;\n        this.points.push(new Point2D(this.rangeX / 2, this.rangeY / 2))\n\n    }\n\n    public get currentPos() {\n        return this._currentPos\n    }\n\n    redraw(): void {\n\n        const c = this.svgCanvas\n\n        // clear\n        c.innerHTML = ''\n\n        // draw all the lines\n        let stroke = '<polyline points=\"'\n        for (let i = 0; i < this.points.length; i++) {\n            const point = this.points[i]\n            // draw the line\n            stroke += point.x.toString()\n            stroke += ','\n            stroke += point.y.toString()\n            stroke += ' '\n        }\n        stroke += '\" style=\"fill: none; stroke: black;stroke-width:3;\" />'\n\n        c.innerHTML += stroke\n\n        // mark the current position\n        const cur = this._currentPos;\n        let marker = '<polygon points=\"0,-10 -10,10 10,10\" transform=\"translate('\n        marker += cur.x.toString()\n        marker += ', '\n        marker += cur.y.toString()\n        marker += ') rotate('\n        marker += (this._currentOrientation / Math.PI * 180).toString()\n        marker += ')\" style=\"fill: none; stroke: #ff00ff;stroke-width:5\" />'\n\n        c.innerHTML += marker\n\n    }\n\n    move(value: number): void {\n        // calc the new position\n        const x = Math.sin(this._currentOrientation) * value;\n        this._currentPos.x += x;\n        const y = Math.cos(this._currentOrientation) * value;\n        this._currentPos.y += y;\n\n        // the new position\n        const newX = this.currentPos.x;\n        const newY = this.currentPos.y;\n\n        // save as a new line\n        this.points.push(\n            new Point2D(newX, newY),\n        );\n    }\n\n    rotate(value: number): void {\n        this._currentOrientation += value / 180 * Math.PI;\n    }\n\n    public reset() {\n        this._currentPos = new Point2D(this.rangeX / 2, this.rangeY / 2)\n        this._currentOrientation = 0\n        this.points = []\n        this.points.push(new Point2D(this.rangeX / 2, this.rangeY / 2))\n        this.redraw()\n    }\n\n}\n","import { MyCanvas } from \"./my-canvas\";\nimport { LogoInterpreter } from './interpreter';\nimport { CanvasRenderer } from './canvas-renderer';\nimport { SVGCanvas } from './svg-canvas';\n\nconsole.log('merdas')\n// get all the necessary elements\nconst form = document.getElementById('execution-form')\nconst input = document.getElementById('command-input') as HTMLInputElement\nconst canvas = document.getElementById('canvas') as HTMLCanvasElement\nconst svgCanvas = document.getElementsByTagName('svg')[0] as unknown as SVGElement\nconst clearButton = document.getElementById('clear-button') as HTMLButtonElement\nconst switchCanvasButton = document.getElementById('switch-canvas') as HTMLButtonElement\n\nconst exampleButtons = document.getElementsByClassName('example-button') as HTMLCollectionOf<HTMLButtonElement>\n\nif (form !== null && input !== null && canvas !== null && svgCanvas !== null && clearButton !== null) {\nconsole.log('merdas')\n\n    // by default hide the SVG canvas\n    svgCanvas.style.display = 'none'\n\n    let myCanvas: CanvasRenderer = new MyCanvas(canvas)\n\n    myCanvas.redraw()\n\n    switchCanvasButton.onclick = (event: Event) => {\n        if (myCanvas instanceof MyCanvas) {\n            canvas.style.display = 'none'\n            svgCanvas.style.display = 'initial'\n            switchCanvasButton.innerText = 'Switch canvas mode, current: SVG'\n            myCanvas = new SVGCanvas(svgCanvas)\n        } else {\n            svgCanvas.style.display = 'none'\n            canvas.style.display = 'initial'\n            switchCanvasButton.innerText = 'Switch canvas mode, current: CANVAS'\n            myCanvas = new MyCanvas(canvas)\n        }\n        myCanvas.redraw()\n    }\n\n    form.onsubmit = (event: Event) => {\n\n        // prevent refreshing the page\n        event.preventDefault()\n\n        setTimeout(async () => {\n\n            // get the value\n            const tokens = input.value\n\n            const interpreter = new LogoInterpreter(myCanvas)\n\n            await interpreter.ExecuteCommandStack(tokens)\n\n            await myCanvas.redraw()\n\n        }, 50)\n    }\n\n    clearButton.onclick = (event: Event) => {\n\n        event.preventDefault()\n\n        myCanvas.reset()\n\n    }\n\n    const examples = [\n        `\nF 100\nR 90\nF 100\nR 90\nF 100\nR 90\nF 100\n        `,\n        `\nRE 5 [F 100 R 72]\n        `,\n        `\nRE 9 [F 100 R 40]\n        `,\n        `\nBE koch 2 :st :a\n    IF :st = 0 [ F :a TE ]\n    koch CA :st - 1 CA :a / 3 R 60\n    koch CA :st - 1 CA :a / 3 L 120\n    koch CA :st - 1 CA :a / 3 R 60\n    koch CA :st - 1 CA :a / 3\nEN\n\n\nBE star 2 :st :a\n    RE 3 [ koch :st :a L 120]\nEN\n\nstar 5 300\n        `,\n        `\nBE troj 1 :a\n    RE 3 [F :a R 120]\nEN\n\nBE sierp 2 :n :a\n    IF :n = 0 [troj :a TE]\n    troj :a\n\n    sierp CA :n - 1 CA :a / 2\n    F CA :a / 2\n    sierp CA :n - 1 CA :a / 2\n    R 60\n    F CA :a / 2 R 60\n\n    sierp CA :n - 1 CA :a / 2\n    L 60 B CA :a / 2\n    L 60 B CA :a / 2\nEN\n\nBE sierpinski 2 :n :a\n    R 30\n    sierp :n :a\nEN\n\nsierpinski 5 300\n\n        `\n    ]\n\n    for (let i = 0; i < exampleButtons.length; i++) {\n        const button = exampleButtons[i]\n        const example = examples[i]\n\n        button.onclick = (event: Event) => {\n            input.value = example\n        }\n    }\n\n}\n"],"names":["$4637b441e76e2d234d42edafff295e88$export$Point2D","constructor","x","y","$d880b3961284c5bb18440a7156c0b652$export$MyCanvas","points","canvasElement","this","maxX","width","minX","maxY","height","minY","rangeX","rangeY","_currentPos","_currentOrientation","push","context","getContext","lineWidth","strokeStyle","setToPrimaryColour","setToSecondaryColour","c","clearRect","moveTo","beginPath","i","length","point","lineTo","stroke","closePath","cur","arc","Math","PI","move","value","sin","cos","newX","currentPos","newY","rotate","reset","redraw","$1799a47d1eab20dada05389cd360a029$export$CommandToken","CommandToken","$1799a47d1eab20dada05389cd360a029$export$MathOperator","MathOperator","allValues","Object","keys","map","key","val","indexOf","$1799a47d1eab20dada05389cd360a029$export$CommandStack","pointer","stack","trim","split","commandStack","pop","popUntil","until","output","popCount","count","hard","splice","slice","putBack","elements","insert","element","index","removePrevious","terminate","$1799a47d1eab20dada05389cd360a029$export$LogoProcedure","_stack","_args","$0be8c7e46a8de84eacdce14c7e31304d$var$parseDecimal","parseInt","$0be8c7e46a8de84eacdce14c7e31304d$export$LogoInterpreter","procedures","myCanvas","handleAtomicAction","action","rawValue","FORWARD","BACKWARD","LEFT","RIGHT","tokenStack","preComputeMathExpressions","isDone","handleCommand","findEndingBracket","openingBracketIndex","innerLoops","s","BRACKET_OPEN","BRACKET_CLOSE","computeCondition","left","operator","right","EQUALS","computeExpression","DIVIDE","ADD","MULTIPLY","SUBTRACT","e","CALC","result","isNaN","String","actionToken","isOfType","REPEAT","timesRaw","repeat","IF","conditionElements","PROCEDURE_BEGIN","name","argCount","args","procedureInnerStack","PROCEDURE_END","procedure","from","PROCEDURE_TERMINATE","includes","argValues","innerStack","copy","forEach","currentElement","$5b5760b736cb68c1af09b28fdffdb2b2$export$SVGCanvas","svgCanvas","clientWidth","clientHeight","innerHTML","toString","marker","console","log","$2b11221472b549b86b9a14abf87e51c7$var$form","document","getElementById","$2b11221472b549b86b9a14abf87e51c7$var$input","$2b11221472b549b86b9a14abf87e51c7$var$canvas","$2b11221472b549b86b9a14abf87e51c7$var$svgCanvas","getElementsByTagName","$2b11221472b549b86b9a14abf87e51c7$var$clearButton","$2b11221472b549b86b9a14abf87e51c7$var$switchCanvasButton","$2b11221472b549b86b9a14abf87e51c7$var$exampleButtons","getElementsByClassName","style","display","onclick","event","innerText","onsubmit","preventDefault","setTimeout","async","tokens","interpreter","ExecuteCommandStack","examples","button","example"],"version":3,"file":"index.8185b07c.js.map"}