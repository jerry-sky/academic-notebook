<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="pl" xml:lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Jerry Sky" />
  <title>Lista-1</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="/style.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@500&display=swap" rel="stylesheet">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Lista-1</h1>
<p class="author">
    <span>by </span>
    <span class="author">Jerry Sky</span>
</p>
</header>
<hr />
<ul>
<li><a href="#zadanie-1">Zadanie 1.</a>
<ul>
<li><a href="#11">1.1.</a></li>
<li><a href="#12">1.2.</a></li>
<li><a href="#13">1.3.</a></li>
<li><a href="#14">1.4.</a></li>
<li><a href="#15">1.5.</a></li>
</ul></li>
<li><a href="#zadanie-2">Zadanie 2.</a></li>
<li><a href="#zadanie-3">Zadanie 3.</a>
<ul>
<li><a href="#31">3.1.</a></li>
<li><a href="#32">3.2.</a></li>
<li><a href="#33">3.3.</a></li>
</ul></li>
<li><a href="#zadanie-4">Zadanie 4.</a>
<ul>
<li><a href="#41">4.1.</a></li>
<li><a href="#42">4.2.</a></li>
</ul></li>
<li><a href="#zadanie-5">Zadanie 5.</a>
<ul>
<li><a href="#51">5.1.</a></li>
<li><a href="#52">5.2.</a></li>
</ul></li>
<li><a href="#zadanie-6">Zadanie 6.</a>
<ul>
<li><a href="#61">6.1.</a></li>
<li><a href="#62">6.2.</a></li>
<li><a href="#63">6.3.</a></li>
</ul></li>
<li><a href="#zadanie-7">Zadanie 7.</a></li>
<li><a href="#zadanie-8">Zadanie 8.</a></li>
</ul>
<hr />
<h2 id="zadanie-1.">Zadanie 1.</h2>
<blockquote>
<p>Podać deterministyczne automaty skończone (DFA) akceptujące następujące języki nad alfabetem <span class="math inline">\(\{0,1\}\)</span>.</p>
</blockquote>
<h3 id="section">1.1.</h3>
<blockquote>
<p>zbiór wszystkich łańcuchów o zakończeniu <span class="math inline">\(101\)</span></p>
</blockquote>
<div class="figure">
<img src="1.1.png" />

</div>
<ul>
<li>na początku mamy stan oczekujący aż nie zostanie wykryty początek żądanego suffiksu</li>
<li>następne stany reprezentują poszczególne etapy w wykrywaniu suffiksu</li>
<li>mamy też powroty, kiedy żądany pattern zostanie złamany</li>
</ul>
<h3 id="section-1">1.2.</h3>
<blockquote>
<p>zbiór wszystkich łańcuchów zawierających trzy kolejne jedynki</p>
</blockquote>
<div class="figure">
<img src="1.2.png" />

</div>
<ul>
<li>na początku oczekujemy na żądany pattern</li>
<li>kolejne stany to poszczególny etapy wykrywania infiksu</li>
<li>mamy powroty, kiedy pattern zostanie złamany</li>
<li>po dojściu do stanu akceptującego, infiks jest już gwarantowany — ciąg może iść dalej lub się skończyć</li>
</ul>
<h3 id="section-2">1.3.</h3>
<blockquote>
<p>zbiór wszystkich łańcuchów, w których każdy blok złożony z pięciu kolejnych symboli zawiera co najmniej dwa zera</p>
</blockquote>
<p><em>Zakładamy, że słowa krótsze niż 5 nie należą do języka.</em></p>
<ul>
<li>DFA <span class="math inline">\(M = (Q, \Sigma, \delta, q_{\epsilon}, F)\)</span></li>
<li>Stany <span class="math inline">\(Q = \left\{ q_a, q_{ab}, q_{abc}, q_{abcd}, q_{abcde}: a,b,c,d,e \in \{0,1\} \right\} \cup \{q_{\epsilon}, q_{s}\}\)</span></li>
<li>Alfabet <span class="math inline">\(\Sigma = \{0,1\}\)</span></li>
<li>Funkcja przejścia: <span class="math display">\[
\delta(q_\epsilon, a) = q_a\\
\delta(q_a, b) = q_{ab}\\
\delta(q_{ab}, c) = q_{abc}\\
\delta(q_{abc}, d) = q_{abcd}\\
\delta(q_{abcd}, e) =
\begin{cases}
    q_{abcde} &amp; a+b+c+d+e \le 3\\
    q_s &amp; \text{oth.}
\end{cases}\\
\delta(q_{abcde}, f) =
\begin{cases}
    q_{bcdef} &amp; b+c+d+e+f \le 3\\
    q_s &amp; \text{oth.}
\end{cases}\\
\delta(q_s, a) = q_s
\]</span> gdzie <span class="math inline">\(a,b,c,d,e,f \in \{0,1\}\)</span></li>
<li>Stany akceptujące <span class="math inline">\(F = \left\{ a+b+c+d+e \le 3 \right\}\)</span> gdzie <span class="math inline">\(a,b,c,d,e,f \in \{0,1\}\)</span></li>
</ul>
<h3 id="section-3">1.4.</h3>
<blockquote>
<p>zbiór wszystkich łańcuchów zaczynających się od <span class="math inline">\(1\)</span>, które interpretowane jako binarna reprezentacja liczby całkowitej są wielokrotnością <span class="math inline">\(7\)</span></p>
</blockquote>
<ul>
<li>dopisanie <span class="math inline">\(0\)</span> na końcu oznacza przemnożenie przez <span class="math inline">\(2\)</span></li>
<li>dopisanie <span class="math inline">\(1\)</span> na końcu oznacza przemnożenie przez <span class="math inline">\(2\)</span> i dodanie <span class="math inline">\(1\)</span></li>
<li>stany <span class="math inline">\(q_0, \dots, q_6\)</span> symbolizują reszty <span class="math inline">\(\operatorname{mod} 7\)</span></li>
</ul>
<div class="figure">
<img src="1.4.png" />

</div>
<h3 id="section-4">1.5.</h3>
<blockquote>
<p>zbiór wszystkich łańcuchów, w których piąty symbol od końca jest zerem</p>
</blockquote>
<ul>
<li>DFA <span class="math inline">\(M = (Q, \Sigma, \delta, q_{11111}, F)\)</span></li>
<li>Stany <span class="math inline">\(Q = \left\{ q_{abcde}: a,b,c,d,e \in \{0,1\} \right\}\)</span></li>
<li>Alfabet <span class="math inline">\(\Sigma = \{0,1\}\)</span></li>
<li>Funkcja przejścia <span class="math inline">\(\delta(q_{abcde}, f) = a_{bcdef}\)</span> gdzie <span class="math inline">\(a,b,c,d,e,f \in \{0,1\}\)</span></li>
<li>Stany akceptujące <span class="math inline">\(F = \left\{ q_{abcde}: a = 0 \land b,c,d,e \in \{0,1\} \right\}\)</span></li>
</ul>
<hr />
<h2 id="zadanie-2.">Zadanie 2.</h2>
<blockquote>
<p>Podać niedeterministyczny automat skończony (NFA) akceptujący następujący język: zbiór wszystkich łańcuchów zer i jedynek, w których dziesiąty symbol od końca jest jest jedynką. Jaki jest związek między rozwiązaniem tego zadania a <a href="#15">zadania 1.5.</a>?</p>
</blockquote>
<div class="figure">
<img src="2.png" />

</div>
<p>W <a href="#zadanie-1">zadaniu 1.5.</a> liczba stanów rośnie wykładniczo właśnie przez to, że mamy tam DFA. Tutaj mamy NFA i możemy pozwolić na taki „niedeterminizm” przy stanie <span class="math inline">\(q_0\)</span> gdzie znak <span class="math inline">\(1\)</span> może oznaczać przejście do następnego stanu, ale może też tego nie oznaczać.</p>
<hr />
<h2 id="zadanie-3.">Zadanie 3.</h2>
<blockquote>
<p>Skonstruować automaty skończone równoważne z następującymi wyrażeniami regularnymi:</p>
</blockquote>
<h3 id="section-5">3.1.</h3>
<blockquote>
<p><span class="math inline">\(10 + (0 + 11)0*1\)</span></p>
</blockquote>
<div class="figure">
<img src="3.1.png" />

</div>
<h3 id="section-6">3.2.</h3>
<blockquote>
<p><span class="math inline">\(01\big[ ((10)^* + 111)^* + 0 \big]^*1\)</span></p>
</blockquote>
<div class="figure">
<img src="3.2.png" />

</div>
<p>(bez części na różowo mamy NFA)</p>
<h3 id="section-7">3.3.</h3>
<blockquote>
<p><span class="math inline">\(((0 + 1)(0 + 1))^∗ + ((0 + 1)(0 + 1)(0 + 1))^∗\)</span></p>
</blockquote>
<p>NFA z <span class="math inline">\(\epsilon\)</span>-przejściami<br />
<img src="3.3.png" /></p>
<p>NFA<br />
<img src="3.3-2.png" /></p>
<p>DFA<br />
<img src="3.3-3.png" /></p>
<hr />
<h2 id="zadanie-4.">Zadanie 4.</h2>
<blockquote>
<p>Skonstruować wyrażenia regularne odpowiadające następującym automatom:</p>
</blockquote>
<h3 id="section-8">4.1.</h3>
<blockquote>
<p><span class="math inline">\((\{A, B, C\}, \{0, 1\}, \{(A, 0) \to A,(A, 1) \to B,(B, 0) \to C,(B, 1) \to B,(C, 0) \to A,(C, 1) \to B \}, A, \{A\})\)</span></p>
</blockquote>
<p><span class="math inline">\((1+0)^*00 + 0 \epsilon\)</span><br />
<img src="4.1.png" /></p>
<h3 id="section-9">4.2.</h3>
<blockquote>
<p><span class="math inline">\((\left\{ A,B,C \right\}, \left\{ 0,1 \right\},\\\left\{ (A,0) \to B, (A,1) \to C, (B,0) \to A, (B,1) \to C, (C,0) \to B, (C,1) \to A, \right\},\\ A, \left\{ B,C \right\})\)</span></p>
</blockquote>
<p><span class="math inline">\((0+1)^* (10 + 01) + 0 + 1\)</span><br />
<img src="4.2.png" /></p>
<hr />
<h2 id="zadanie-5.">Zadanie 5.</h2>
<blockquote>
<p>Udowodnić następujące tożsamości dla wyrażeń regularnych <span class="math inline">\(r\)</span>, <span class="math inline">\(s\)</span> i <span class="math inline">\(t\)</span>, przy czym <span class="math inline">\(r = s\)</span> oznacza identyczność języków opisywanych przez <span class="math inline">\(r\)</span> i <span class="math inline">\(s\)</span>.</p>
</blockquote>
<ul>
<li><span class="math inline">\(r,s,t\)</span> reprezentują odpowiednio języki <span class="math inline">\(R\)</span>, <span class="math inline">\(S\)</span>, <span class="math inline">\(T\)</span></li>
<li><span class="math inline">\(r+s\)</span> reprezentuje język <span class="math inline">\(R \cup S\)</span></li>
<li><span class="math inline">\(rs\)</span> reprezentuje złożenie <span class="math inline">\(RS = \left\{ xy: x \in R, y \in S \right\}\)</span></li>
<li><span class="math inline">\(r^*\)</span> reprezentuje domknięcie Kleene’ego <span class="math inline">\(R^* = \bigcup_{i=0}^{\infty} R^i\)</span>, gdzie <span class="math inline">\(R^0 = \{\epsilon\}\)</span>, <span class="math inline">\(R^i = RR^{i-1}\)</span> dla <span class="math inline">\(i \ge 1\)</span></li>
<li><span class="math inline">\(\emptyset\)</span> reprezentuje <span class="math inline">\(\emptyset\)</span></li>
<li><span class="math inline">\(\epsilon\)</span> reprezentuje <span class="math inline">\(\{\epsilon\}\)</span></li>
</ul>
<h3 id="section-10">5.1.</h3>
<blockquote>
<p><span class="math inline">\((r + s) + t = r + (s+t)\)</span></p>
</blockquote>
<ul>
<li><span class="math inline">\(x \in (R\cup S) \cup T \iff x \in (R\cup S) \lor x \in T\)</span></li>
<li><span class="math inline">\(x \in R \lor x \in S \lor x \in T\)</span></li>
<li><span class="math inline">\(x \in R \cup (S\cup T)\)</span></li>
</ul>
<h3 id="section-11">5.2.</h3>
<blockquote>
<p><span class="math inline">\((rs)t = r(st)\)</span></p>
</blockquote>
<ul>
<li><span class="math inline">\(x \in (RS)T \iff \exists x_1, x_2 \enspace (x = x_1 x_2 \land x_1 \in RS \land x_2 \in T) \iff \exists x_1, x_2 \enspace (x = x_1x_2 \land (\exists y_1, y_2 \enspace (x_1 = y_1 y_2 \land y_1 \in R \land y_2 \in S) \land x_2 \in T) \iff \dots\)</span></li>
<li><span class="math inline">\(x \in R(ST)\)</span></li>
</ul>
<p><span class="math display">\[
\dots
\]</span></p>
<hr />
<h2 id="zadanie-6.">Zadanie 6.</h2>
<blockquote>
<p>Udowodnić lub obalić następujące tożsamości dla wyrażeń regularnych r, s i t:</p>
</blockquote>
<h3 id="section-12">6.1.</h3>
<blockquote>
<p><span class="math inline">\((rs + r)^* r = r(sr + r)^*\)</span></p>
</blockquote>
<p>Pokażemy indukcyjnie, że <span class="math inline">\((rs + r)^n r = r(sr + r)^n\)</span>.</p>
<ol style="list-style-type: decimal">
<li><p><span class="math inline">\(n = 1\)</span></p>
<ul>
<li><span class="math inline">\((rs + r) r = r (sr + r)\)</span></li>
<li><span class="math inline">\(rsr + r = rsr + r\)</span></li>
<li>czyli OK</li>
</ul></li>
<li><p><span class="math inline">\(n \implies n+1\)</span></p>
<ul>
<li>zakładamy, że <span class="math inline">\((rs + r)^n r = r(sr + r)^n\)</span></li>
<li><span class="math inline">\((rs + r)^{n+1} r = (rs + r) r (sr + r)^n\)</span></li>
<li><span class="math inline">\((rs + r)^{n+1} r = (rsr + rr) (sr + r)^n\)</span></li>
<li><span class="math inline">\((rs + r)^{n+1} r = r(sr + r) (sr + r)^n\)</span></li>
<li><span class="math inline">\((rs + r)^{n+1} r = r(sr + r)^{n+1}\)</span></li>
<li><span class="math inline">\(\blacksquare\)</span></li>
</ul></li>
</ol>
<h3 id="section-13">6.2.</h3>
<blockquote>
<p><span class="math inline">\((r + s)^* = r^* + s^*\)</span></p>
</blockquote>
<p>Wyrażenie nieprawdziwe.</p>
<p>Po lewej stronie możemy mieć słowo <span class="math inline">\(rsrs\)</span>, które nie jest akceptowane przez prawą stronę.<br />
Lewa strona zezwala na mieszanie się znaków, prawa strona dzieli litery na dwie homogeniczne części.</p>
<h3 id="section-14">6.3.</h3>
<blockquote>
<p><span class="math inline">\(s(rs + s)^* r = rr^* s(rr^* s)^*\)</span></p>
</blockquote>
<p>Wyrażenie nieprawdziwe.</p>
<p>Lewa strona zawsze zaczyna się od <span class="math inline">\(s\)</span>, kiedy prawa zaczyna od <span class="math inline">\(r\)</span>.</p>
<hr />
<h2 id="zadanie-7.">Zadanie 7.</h2>
<blockquote>
<p>Udowodnić, że DFA akceptujący język słów nad alfabetem <span class="math inline">\(\{0, 1\}\)</span>, w których piąty symbol od prawego końca jest jedynką, musi mieć co najmniej <span class="math inline">\(32\)</span> stany.</p>
</blockquote>
<p>Załóżmy, że istnieje DFA <span class="math inline">\(M\)</span> o <span class="math inline">\(31\)</span> stanach. Rozważmy dwa różne słowa długości <span class="math inline">\(5\)</span> należące do rozpatrywanego języka: - <span class="math inline">\(s_1 = i_1\dots i_5\)</span> - <span class="math inline">\(s_2 = j_1\dots j_5\)</span></p>
<p>Zatem istnieją dwa różne słowa długości <span class="math inline">\(5\)</span>, które wczytywane prowadzą do tego samego stanu <span class="math inline">\(q\)</span>. 1. Jeśli różnią się na pierwszej pozycji <span class="math inline">\((i_1 \neq j_1)\)</span>, to sprzeczność z założeniem, że oba słowa należą do języka (jedno z nich ma zero na początku). 2. Załóżmy, że <span class="math inline">\(i_1 = j_1\)</span>. Dopisujemy na końcu obu słów ten sam znak <span class="math inline">\(a \in \{0,1\}\)</span></p>
<p>Wczytujemy <span class="math inline">\(a\)</span>. W przypadku obu słów, wychodząc z tego samego stanu <span class="math inline">\(q\)</span> z literą <span class="math inline">\(a\)</span> automat powinien przejść do tego samego stanu <span class="math inline">\(p\)</span> (bo to DFA). Zatem <span class="math inline">\(i_2 = j_2\)</span> (stan nie może być jednocześnie akceptujący i nieakceptujący).</p>
<p>Idąc dalej podobnym tokiem rozumowania, dostaniemy <span class="math inline">\(\forall x \enspace i_x = j_x\)</span> co jest sprzeczne z założeniem, że <span class="math inline">\(s_1 \neq s_2\)</span>.</p>
<p>W <a href="#15">zadaniu 1.5.</a> pokazaliśmy, że <span class="math inline">\(32\)</span> stany są wystarczające dla tego typu języka.</p>
<hr />
<h2 id="zadanie-8.">Zadanie 8.</h2>
<blockquote>
<p>Skonstruuj NFA rozpoznający język tych słów nad <span class="math inline">\(\{0, 1\}^*\)</span> które jako liczba w systemie dwójkowym dzielą się przez <span class="math inline">\(5\)</span>, przy czym liczba jest wczytywana, począwszy od najmniej znaczącego bitu.</p>
</blockquote>
<p>Budujemy automat dla modelu wczytywania od najbardziej znaczącego bitu, a następnie aplikujemy metodę inwersji: 1. Zbiór stanów może zostać rozszerzony o <span class="math inline">\(q_0&#39;\)</span>, z którego prowadzimy <span class="math inline">\(\epsilon\)</span>-przejścia do stanów akceptujących w automacie <span class="math inline">\(M\)</span> 2. Stan początkowy z <span class="math inline">\(M\)</span> czynimy w <span class="math inline">\(M&#39;\)</span> stanem akceptującym. 3. „Odwracamy” w automacie <span class="math inline">\(M&#39;\)</span> ścieżki z <span class="math inline">\(M\)</span>.</p>
<div class="figure">
<img src="8.png" />

</div>
<hr />
</body>
</html>
