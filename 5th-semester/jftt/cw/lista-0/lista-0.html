<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="pl" xml:lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Jerry Sky" />
  <title>Lista 0</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <link rel="stylesheet" href="/style.css" />
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=Merriweather&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@500&display=swap" rel="stylesheet">
</head>
<body>
<header id="title-block-header">
<h1 class="title">Lista 0</h1>
<p class="author">
    <span>by </span>
    <span class="author">Jerry Sky</span>
</p>
</header>
<hr />
<ul>
<li><a href="#zadanie-1">Zadanie 1.</a></li>
<li><a href="#zadanie-2">Zadanie 2.</a></li>
<li><a href="#zadanie-3">Zadanie 3.</a></li>
</ul>
<hr />
<h2 id="zadanie-1.">Zadanie 1.</h2>
<blockquote>
<p>Udowodnić, że najdłuższa ścieżka od korzenia do liścia w dowolnym drzewie binarnym o <span class="math inline">\(n\)</span> wierzchołkach ma co najmniej <span class="math inline">\(\lfloor\log_2n\rfloor\)</span> krawędzi.</p>
</blockquote>
<p>Musimy sprawdzić jak sytuacja wygląda dla <em>drzew zbalansowanych</em>, jako że to drzewa zbalansowane mają najkrótsze «drogi najdłuższe». Innymi słowy — chodzi o drzewa o jak najmniejszej wysokości.</p>
<p>Bez straty ogólności niech <span class="math display">\[
n = 2^k + l\\
\text{gdzie } l \in [0; 2^k) \cap \mathbb{N}
\]</span></p>
<div class="figure">
<img src="1.drzewo-binarne-1.png" alt="drzewo binarne" />
<p class="caption">drzewo binarne</p>
</div>
<p>Warto zauważyć, że w przypadku drzewa zbalansowanego dodajemy kolejne węzły na tym samym „poziomie” i nie zaczynamy dodawać węzłów na następnych „poziomach” jeśli jest jeszcze miejsce na aktualnym.</p>
<div class="figure">
<img src="1.drzewo-binarne-2.png" alt="drzewo binarne 2^(k+1) - 1" />
<p class="caption">drzewo binarne 2^(k+1) - 1</p>
</div>
<p><span class="math display">\[
2^0 + 2^1 + 2^2 + \dotsb + 2^k = 2^{k+1} - 1
\]</span></p>
<p>(korzystamy z <a href="#zadanie-3">zadania 3.2.</a> przy tamtejszym <span class="math inline">\(k=2\)</span>)</p>
<p>Dalej, widzimy, że wysokość naszego drzewa jest taka sama dla liczby węzłów w przedziale <span class="math inline">\([2^k; 2^{k+1} - 1]\)</span> i wynosi ona dokładnie <span class="math inline">\(k\)</span> co zgadza się z tym czego oczekiwaliśmy:<br />
wynik logarytmu „spłaszczamy”, bierzemy część całkowitą: <span class="math display">\[
\lfloor \log_2(2^k + l) \rfloor = log_2(2^k) = k
\]</span></p>
<p><span class="math inline">\(k\)</span> — liczba o 1 mniejsza niż liczba węzłów na najdłuższej drodze czyli liczba krawędzi.</p>
<hr />
<h2 id="zadanie-2.">Zadanie 2.</h2>
<blockquote>
<p>Uogólnij zadanie 1. na drzewo, w którym każdy wierzchołek ma co najwyżej <span class="math inline">\(\cancel{k}\)</span> <span class="math inline">\(p\)</span> synów.</p>
</blockquote>
<p>Dokonujemy zmian w <a href="#zadanie-1">powyższych rozważaniach</a>: - zamieniamy <span class="math inline">\(2\)</span> na żądaną zmienną - zamieniamy sumę <span class="math inline">\(\sum_{i=0}^{k+1}2^i = 2^{k+1} - 1\)</span> na sumę <span class="math inline">\(\sum_{i=0}^{k+1}p^i = \frac{p^{k+1} - 1}{p - 1}\)</span> - zmieniamy przedział: <span class="math inline">\(l \in \left[0; p^{k}\cdot(p-1)\right)\cap \mathbb{N}\)</span></p>
<hr />
<h2 id="zadanie-3.">Zadanie 3.</h2>
<blockquote>
<p>Mamy alfabet złożony z <span class="math inline">\(k\)</span> symboli. Policz ile jest:</p>
</blockquote>
<ol style="list-style-type: decimal">
<li><blockquote>
<p>wszystkich różnych słów długości <span class="math inline">\(n\)</span> nad tym alfabetem</p>
</blockquote>
<p><span class="math display">\[
1 \cdot \underbrace{k \cdot k \cdot \dotsb k}_{n \text{ razy}} = k^n
\]</span></p>
<p>ponieważ za każdym razem mamy <span class="math inline">\(k\)</span> możliwości do wyboru litery a potrzebujemy dobrać <span class="math inline">\(n\)</span> liter.</p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(n=0\)</span>: <span class="math inline">\(1 = k^0\)</span> — mamy jedno słowo puste — <em>zgadza się</em></li>
<li><span class="math inline">\(n\implies n+1\)</span>:<br />
mamy <span class="math inline">\(\underbrace{k \cdot k \cdot \dotsb k}_{n \text{ razy}} = k^n\)</span><br />
doklejamy nową literę: dla każdej litery (mamy ich <span class="math inline">\(k\)</span>) mamy osobno nowych <span class="math inline">\(k^n\)</span> słów; zatem:<br />
<span class="math inline">\(\underbrace{k^n + k^n + \dotsb + k^n}_{k\text{ razy}} = k \cdot k^n = k^{n+1}\)</span> ---</li>
</ol></li>
<li><blockquote>
<p>wszystkich różnych słów długości co najwyżej <span class="math inline">\(n\)</span></p>
</blockquote>
<p><strong>Dowód tradycyjny:</strong><br />
Niech <span class="math display">\[
\sum_{i=0}^{n}k^i = S_n
\]</span></p>
<p>Wówczas:</p>
<p><span class="math display">\[
S_n = \sum_{i=0}^{n}k^i\\
//\cdot k
\\
S_n \cdot k = \sum_{i=1}^{n+1}k^i
\\
S_n \cdot k = S_n - 1 + k^{n+1}\\
//-S_n
\\
S_n \cdot (k - 1) = k^{n+1} - 1
\\
\blacksquare
\]</span></p>
<p><strong>Dowód indukcyjny:</strong> <span class="math display">\[
\sum_{i=0}^{n}k^i
=
\frac{k^{n+1} - 1}{k-1}
\]</span></p>
<ol style="list-style-type: decimal">
<li><span class="math inline">\(n=0\)</span>: <span class="math inline">\(1 = k^0 = \frac{k^{1} - 1}{k-1} = 1\)</span> — <em>zgadza się</em></li>
<li><span class="math inline">\(n \implies n+1\)</span>: <span class="math display">\[
\sum_{i=0}^{n}k^i = \frac{k^{n+1} - 1}{k-1}\\
// + k^{n+1}
\\
\sum_{i=0}^{n+1}k^i = \frac{k^{n+1} - 1}{k-1} + \frac{k^{n+1} \cdot (k-1)}{k-1}
\\
\sum_{i=0}^{n+1}k^i = \frac{k^{n+1} - 1 + k^{n+2} - k^{n+1}}{k-1}
\\
\sum_{i=0}^{n+1}k^i = \frac{k^{n+2} - 1}{k-1}
\]</span> <em>zgadza się</em> ---</li>
</ol></li>
<li><blockquote>
<p>wszystkich palindromów długości <span class="math inline">\(n\)</span></p>
</blockquote>
rozważamy dwa przypadki:
<ol style="list-style-type: decimal">
<li><span class="math inline">\(n\)</span> jest parzyste<br />
dobieramy <span class="math inline">\(\frac{n}{2}\)</span> liter z alfabetu <span class="math inline">\(k\)</span>-elementowego na jedną połówkę słowa: <span class="math display">\[
k^{\frac{n}{2}}
\]</span></li>
<li><span class="math inline">\(n\)</span> jest nieparzyste<br />
dobieramy <span class="math inline">\(\left\lfloor \frac{n}{2} \right\rfloor\)</span> liter z alfabetu <span class="math inline">\(k\)</span>-elementowego na jedną połówkę słowa: <span class="math display">\[
k^{\left\lfloor \frac{n}{2} \right\rfloor}
\]</span> dodatkowo dobieramy jedną literę środkową słowa spośród <span class="math inline">\(k\)</span> liter</li>
</ol>
<h2 id="dowód-taki-sam-jak-dla-3.1.">dowód taki sam jak dla «3.1.»</h2></li>
<li><blockquote>
<p>wszystkich palindromów długości co najwyżej <span class="math inline">\(n\)</span></p>
</blockquote>
<p>tak samo jak dla «3.2.» + «3.3.»</p></li>
</ol>
</body>
</html>
